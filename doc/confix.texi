\input texinfo @c -*- texinfo -*-

@setfilename confix.info
@c @settitle Confix

@setchapternewpage on

@titlepage
@title Confix
@subtitle A Build Tool on top of GNU Autoconf and Automake 
@author J@"org Faschingbauer
@code{$Id: confix.texi,v 1.91 2006/02/06 21:47:16 jfasch Exp $}
@end titlepage

@node Top, Introduction, (dir), (dir)
@top Confix

@menu
* Introduction::                
* An Example::                  
* How Confix Works::            
* The Coders Role in the Build Process::  
* The Users Role in the Build Process::  
* Options and Parameters::      
* Interfaces for Coder and Maintainer::  
* The Configuration File::      
* Frequently Asked Questions::  
* The Sample Utilities Package::  
* Concept Index::               
* Function Index::              
* Variable Index::              
@end menu

@contents

@node Introduction, An Example, Top, Top
@chapter Introduction

@c NOTE: this is also in the index.html. Be sure to update it there if you modify it here.

Confix is a build tool for source code packages. It doesn't require
the package maintainer to write any build instructions by hand at
all. Instead, it examines the source code, @emph{guesses} what's to be
done and writes the build instructions for the
maintainer@footnote{Clearly this involves certain rules the source
code must adhere to. But read on.}. Another important feature ---
perhaps the most important --- is the ability of Confix to recognize
and compute dependencies. That is, it relieves the package maintainer
of the task of manually keeping track of the order in which libraries
appear on the link line of an executable, for example, or of the build
order inside the package.

Confix is built on top of the standard open source tool Automake,
@uref{http://www.gnu.org/software/automake/}@footnote{Automake in turn
sits on top of another open source tool called Autoconf,
@uref{http://www.gnu.org/software/autoconf/}.}. That is, the build
instructions generated by Confix are in fact Automake input
files. This way one uses the whole infrastructure supplied by
Automake, involving such things as the well-known @command{configure;
make; make install} sequence, or automatically building source
distributions by simply saying @command{make dist}, just to mention a
few.

@menu
* Prerequisites::               
* How To Get It::               
* Installation::                
* A Short Autotools Introduction::  
* What Confix Adds to the Autotools::  
@end menu

@node Prerequisites, How To Get It, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section Prerequisites
@cindex @code{autoconf}
@cindex @code{automake}
@cindex Python

@itemize @bullet

@item
Python, at least version 2.3.

@item
Automake, at least version 1.7.

@item
Autoconf, at least version 2.58.

@item
Libtool. Support for Libtool is optional in Confix, so you may leave
it out entirely. Best to use version 1.5 because older versions had
buggy C++ support. If you are building C libraries, older versions may
or may not work.

@end itemize

@node How To Get It, Installation, Prerequisites, Introduction
@comment  node-name,  next,  previous,  up
@section How To Get It

The project's homepage it hosted on Sourceforge,
@uref{http://confix.sourceforge.net}. See there for releases,
announcements et cetera.

Throughout this document we will occasionally refer to an example
source code package which is also available from this site. You may
dowload it as a tarball or check it out from
source@footnote{Downloading the tarball is simpler and faster. However
it will not match the documentation exactly because it contains
generated files. Checking out from source is what the documentation is
about because Confix is a maintainer tool. But the differences are
minor, and we will try to place hints wherever the tarball doesn't
match the documentation.}

@node Installation, A Short Autotools Introduction, How To Get It, Introduction
@comment  node-name,  next,  previous,  up
@section Installation

Confix packaging and installation is done using the Python Distutils
package. So far I managed to do a source distribution, both in
@file{.tar.gz} and @file{.zip}, a RPM package, and a ``dumb binary
distribution''. The easiest to use however is the source distribution,
mainly because Confix cannot use the RedHat 7.3 default Python which
is 1.5 (can anybody use it?).

@menu
* Source Distribution::         
* RPM distribution::            
* Dumb binary distribution::    
@end menu

@node Source Distribution, RPM distribution, Installation, Installation
@comment  node-name,  next,  previous,  up
@subsection Source Distribution

Unpack the file, point the @var{PYTHONPATH} environment variable into
the root directory of the Confix package, and your @var{PATH}
environment variable into the @file{scripts} subdirectory thereof. For
example,

@example
@group
$ pwd
/home/jfasch
$ tar zxplf Confix-1.0.1.tar.gz
@end group
@end example

Then make a call to Distutils to build and install the source.

@example
@group
$ cd Confix-1.0.1
$ pwd
/home/jfasch/Confix-1.0.1
$ python setup.py install --prefix=$@{HOME@}/sandbox
@end group
@end example

Then, provided the prefix you gave wasn't a standard one like
@file{/usr} or @file{/usr/local}, you should update your environment
accordingly. For example, you could add the following lines to your
@file{~/.bashrc},

@example
@group
PREFIX=$@{HOME@}/sandbox
export PYTHONPATH=$@{PYTHONPATH@}:$@{PREFIX@}/lib/pythonA.B/site-packages
export PATH=$@{PATH@}:$@{PREFIX@}/bin
@end group
@end example

Make sure A.B corresponds to the version of Python that you use, such
as 2.1 or 2.2.

@node RPM distribution, Dumb binary distribution, Source Distribution, Installation
@comment  node-name,  next,  previous,  up
@subsection RPM distribution

Ideally, one would just say

@example
rpm -Uvh Confix-<version>.noarch.rpm
@end example

However, Confix requires at least Python 2.1.3, and I built the RPM
using the Python binary @file{/usr/local/Python-2.1.3/bin/python}
(which I compiled myself). Unfortunately, the RPM package generated by
Distutils is not relocatable, so the user is required to have Python
installed in /usr/local/Python-2.1.3.

I could have built the RPM with the @command{python2} interpreter
which comes with RedHat 7.3, but, then again, this wouldn't help
because then I'd have to write @code{#!/usr/bin/env python2} in the
first line of the @command{confix.py} script. This would break Confix
for configurations which don't have @command{python2}.

What I want to say: since Confix requires Python 2.1.3 or higher, it
is not easy to generate RPM for RedHat 7.3 whose default Python is
1.5@footnote{One reason for this obscurity is that Python 2 break
startup scripts such as @command{lpd} which rely on Python (1.5)
scripts.}. Better to use the ``dumb binary distribution'' instead.

@node Dumb binary distribution,  , RPM distribution, Installation
@comment  node-name,  next,  previous,  up
@subsection Dumb binary distribution

A ``dumb binary distribution'' is simply a @file{.tar.gz} or
@file{.zip} file containing the tree fit for installation. Unpack it,
chdir to the implicitly contained prefix directory (for example
@file{./usr/local/Python-2.1.3}, note the leading @file{.}, which
means the current directory), and copy everthing contained therein
into your favourite Python root.

@node A Short Autotools Introduction, What Confix Adds to the Autotools, Installation, Introduction
@comment  node-name,  next,  previous,  up
@section A Short Autotools Introduction

@cindex @code{make}
@cindex distribution, source
@cindex source distribution
If you ever compiled a GNU source package, you probably have enjoyed
the convenience of saying @code{configure; make; make install},
without having to manually adjust @file{Makefile}s and source
code. The tools which make this possible are @code{automake} and
@code{autoconf}. They implement one part of the GNU Coding Standards,
namely the part which specifies which @command{make} targets must be
available to the user who compiles the package. Among these targets
are @code{install}, @code{clean}, @code{info} (to generate emacs info
files from Texinfo documentation), @code{check} (to perform tests),
@code{dist} (to automatically generate a source distribution in a
.tar.gz file), and many others.

@cindex @code{configure}
@cindex M4
@command{configure} is a Bourne shell script which performs checks
specified by the maintainer. It is not a hand-written script - as you
can see from looking at it. Rather, it is "compiled" from several input
files written by the maintainer, mostly in the macro language M4. For
example, if the package contains C code, @command{configure} will search
for available C compilers on the user's machine (the @emph{host}
machine), and pick one which is then used to compile the package. Also,
it checks for the availability of certain functions or libraries on
demand of the maintainer. Based on the results of these checks,
@command{configure} creates @file{Makefile}s in the package
subdirectories which have to be built.

@cindex @option{--prefix}
@command{configure} supports a great wealth of commandline options
which parameterize the package build process. One of the most widely
used options is @code{--prefix=<prefix>}. You use this option when you
don't want the package installed at the default location
@file{/usr/local} (e.g. if you don't have write permissions there),
but rather want it installed at
@file{$HOME/my-private-packages}. (@code{--prefix} is the only
standard option we use in this manual, so we don't mention the others
here.)

@command{make install} installs the package into subdirectories of
@file{$(prefix)}. If you haven't passed any other options than
@code{--prefix} to @command{configure}, the header files of the
package will be installed under @file{$(prefix)/include}, the
executables under @file{$(prefix)/bin}, and the libraries under
@file{$(prefix)/lib}. You can explicitly specify locations for each of
these by passing specific options to @command{configure}; see the
@command{autoconf} manual for more information.

@node What Confix Adds to the Autotools,  , A Short Autotools Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section What Confix Adds to the Autotools

@cindex maintainer, of a package
@cindex package maintainer
@cindex build process
As you have noticed, a package maintainer is responsible for at least
two things. On one side, the maintainer hacks the code, a job which
can be quite creative and is fun most of the time. On the other side,
there is the task of crafting the build process. This job is annoying,
it involves such things as keeping track of include paths, library
names, checking for external packages, cross platform portability
issues, etc. The GNU tools Automake and Autoconf largely automate the
build process, but there is still a non-trivial amount of work left.

Confix's goal is to make build maintenance @emph{part} of source code
maintenance. The maintainer is not required to write lengthy
@file{configure.in} and @file{Makefile.am} like he had to when using
plain Automake. Rather, from the content of the package's directories
and files, Confix guesses what has to be built and how.

Clearly Confix imposes a few restrictions (features) on the maintainer
in order for it to be able to correctly guess. This manual goes to
great lengths at explaining what these restrictions are, and how to
live with them. @ref{The Coders Role in the Build Process} has been
written solely for this purpose.

@node An Example, How Confix Works, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter An Example

Let's start out with a concrete example; it's easier to follow the
explanations this way. If you want to immediately try out what's
written in this chapter, I recommend you download the companion
@code{wx-utils} package from the Confix web site (see @ref{How To Get
It}), unpack it, and warm up your fingers. @ref{The Sample Utilities
Package} contains a brief description of what's in that
package. Throughout this manual, we will refer to source files of the
package as examples.

What we will be doing in this chapter is to play through the different
stages of a package,

@itemize @bullet

@item
Raw source code: pure source code, as written by the developer.

@item
Instrumented: instrumented package; files generated by Confix suitable
for input to Automake and Autoconf.

@item
Bootstrapped: prepared by Automake and Autoconf, ready for the user to
call @command{configure} and @command{make}.

@item
Built: configured and compiled by the user.

@item
Installed: made public by calling @command{make install}.

@end itemize

Note that this chapter is about calling Confix to manage your build
process. It is not about crafting the source code itself. For this we
have a separate chapter, @ref{The Coders Role in the Build
Process}. There we describe in detail what you have to bear in mind
when writing code that you intend to manage with Confix. I suggest you
read that chapter before you actually start out with your own package.

@menu
* The Raw Source::              
* Instrumenting the Package::   
* Bootstrapping the Package::   
* The Configuration File (Short Introduction)::  
* Building the Package::        
* Installing the Package::      
* Distributing the Package::    
* Summary::                     
@end menu

@node The Raw Source, Instrumenting the Package, An Example, An Example
@comment  node-name,  next,  previous,  up
@section The Raw Source

@cindex package, raw source
Here's the structure of the package as the maintainer hand-crafted it,
with a few directories and files omitted to make it fit on a
page@footnote{If you downloaded the tarball rather than checked it out
from CVS, then the directory structure is more cluttered. This is
because the tarball is fully instrumented by Confix and Automake, and
thus contains all the generated files that make up the
``bootstrapped'' stage of the package.}.

@example
@group
wx-utils
|-- Makefile.py
|-- bin
|   |-- Makefile.py
|   `-- crypt.cc
|-- check
|   |-- Makefile.py
|   `-- _check_debug_parse_levels.cc
|-- code
|   |-- Makefile.py
|   |-- debug.cc
|   |-- debug.h
|   `-- linkassert.h
|-- crypt
|   |-- Makefile.py
|   |-- crypt.cc
|   `-- crypt.h
|-- error
|   |-- Makefile.py
|   |-- error.cc
|   `-- error.h
`-- ext-crypt
    `-- Makefile.py
@end group
@end example

@cindex @file{Makefile.py}
@cindex directory, instrumenting
@cindex instrumenting
What strikes are the occurrences of @file{Makefile.py} in every
directory. The meaning of this file is twofold. First, all directories
in the package that do not have a @file{Makefile.py} are ignored by
Confix. In other words, you have to place a @file{Makefile.py} in
every directory that you want Confix to instrument.

Second, that file may contain explicit instructions for Confix on how
to instrument that particular directory. But this is more advanced
stuff; suffice it for now to say that this file is usually empty and
only serves as a reminder for Confix to not overlook that
directory. If you do feel the need to write something there - such as
CVS keyword substitutions in a comment - be sure to use Python syntax
for this. See @ref{The Module Makefile.py Interface} for information
about what can be written in @file{Makefile.py}. If you are curious, I
suggest you take a look at @file{Makefile.py} in
@file{ext-crypt}. This directory does not contain any real code;
rather, its @file{Makefile.py} contains information on how to use the
standard UNIX crypt library. You'll find a explanation in @ref{A
Simple External Module}.

@strong{A few words on terminology.} Throughout this manual we will
use certain terms over and over again. Now's the right time to
formally introduce two of them.

@itemize @bullet

@item
@cindex package
@cindex package root
@cindex package name
@emph{Package:} a package is an entity which is subject to be
instrumented by Confix. In our example, the tree beginning at the
@file{wx-utils} directory is a package, and @file{wx-utils} is the
@emph{package root}.

@item
@cindex module
@emph{Module:} a module is a subdirectory of the package root. A
package is said to contain modules. A module normally contains
buildable things such as C and C++ files and the like (more on that
later). The outcome of a module, after the package has been built, is
something like a C or C++ library, an executable, or whatnot.

@end itemize

@node Instrumenting the Package, Bootstrapping the Package, The Raw Source, An Example
@comment  node-name,  next,  previous,  up
@section Instrumenting the Package

@cindex instrumented package
The first step on the way to a successful build (apart from writing
correct code and spreading @file{Makefile.py} files all over the
package tree) is to have Confix examine the package and generate input
for the Autotools.

@example
@group

$ pwd
/home/jfasch/work/wx-utils
$ confix.py --prefix=/home/jfasch/installed-packages --output
scanning package (wx-utils) ...
done with wx-utils
resolving dependencies ...
done resolving

@end group
@end example

Now see what has happened. (See below what the @option{--prefix}
option is for.)

@example
@group

wx-utils
|-- configure.in
|-- Makefile.am
|-- Makefile.py
|-- depcomp
|-- bin
|   |-- Makefile.am
|   |-- Makefile.py
|   |-- crypt.cc
|   `-- wx-utils_bin.py
|-- check
|   |-- Makefile.am
|   |-- Makefile.py
|   |-- _check_debug_parse_levels.cc
|   `-- wx-utils_check.py
|-- code
|   |-- Makefile.am
|   |-- Makefile.py
|   |-- debug.cc
|   |-- debug.h
|   |-- linkassert.h
|   `-- wx-utils_code.py
|-- crypt
|   |-- Makefile.am
|   |-- Makefile.py
|   |-- crypt.cc
|   |-- crypt.h
|   `-- wx-utils_crypt.py
|-- error
|   |-- Makefile.am
|   |-- Makefile.py
|   |-- error.cc
|   |-- error.h
|   `-- wx-utils_error.py
`-- ext-crypt
    |-- Makefile.am
    |-- Makefile.py
    `-- wx-utils_ext-crypt.py

@end group
@end example

@cindex @file{configure.in}
@cindex @file{Makefile.am}
Confix created a couple of files in the tree. @file{configure.in} is
the input for the Autoconf tool. It contains M4 code which will be
expanded to bourne shell code by Autoconf in the next step. The
various @file{Makefile.am} files, in the package root directory and
its module directories are input for Automake and will be expanded to
Autoconf input in the next step. It does not matter if you do not
understand what is going on here. You do not normally need to. If you
do want to understand it, we refer you to the Autoconf and Automake
documentation. Also, there is a
@uref{http://sources.redhat.com/autobook/,good book} about both of
them, written by some of the maintainers. Suffice it to say that
Confix just did what is otherwise the package maintainer's job: it
wrote input files for the Autotools. This is the state of a package as
you would check it out from anonymous CVS if it were a regular open
source project on the Internet.

@cindex module description file
@cindex description file, of a module
@cindex properties of a module
@cindex module properties
@cindex Python
There are a few files I did not mention: @file{wx-utils_bin.py},
@file{wx-utils_check.py}, @file{wx-utils_code.py}, @file{wx-utils_crypt.py},
@file{wx-utils_error.py}, and @file{wx-utils_ext-crypt.py}. They contain
pickled@footnote{That is, marshalled by the standard Python
@code{pickle} module.} Python objects whose purpose is to describe the
properties of the respective module. When the package is installed,
these description files are installed along with the other content of
the package and made available for other packages that use this
package. When Confix instruments that other package, it uses these
description files to calculate inter-package dependencies (see
@ref{Module Repository --- Inter-Package Knowledge Transfer}).

@cindex dependencies, inter-package
@cindex inter-package dependencies
Inter-package dependencies are the reason why one must use the
@option{--prefix} option when instrumenting a package. Strictly
speaking, it is not necessary to specify @option{--prefix} when
instrumenting the @code{wx-utils} package since it does not depend on any
other package. Nevertheless, we use it for clarity because our example
package could just as well depend on another package.

@node Bootstrapping the Package, The Configuration File (Short Introduction), Instrumenting the Package, An Example
@comment  node-name,  next,  previous,  up
@section Bootstrapping the Package

@cindex bootstrapping
@cindex @file{configure.in}
@cindex @command{configure}
@cindex @file{Makefile.am}
@cindex @file{Makefile.in}
@cindex portability, Bourne shell
@cindex portability, @command{make}
@cindex Bourne shell
@cindex @command{make}
In Autotools talk, the term @emph{bootstrapping} refers to the process
of converting the input files, @file{configure.in} and
@file{Makefile.am}, to the files the end user sees, primarily
@file{configure} and @file{Makefile.in}. The Autotools are
@emph{maintainer} tools and require the presence of other tools such
as Perl and M4 which the user may not have installed at his
site. @file{configure.in}, for example, is a bunch of M4 macro
invocations which, when expanded by Autoconf, turn into an even
greater (and even more unreadable) bunch of Bourne shell code, the
@file{configure} script. Likewise, @file{Makefile.am} is a bunch of
bells and whistles, subject to be parsed and interpreted by the Perl
program Automake. The outcome of a @file{Makefile.am} is a file
@file{Makefile.in} which looks like an ordinary @file{Makefile}, only
with some placeholders to be substituted by the user, by calling
@command{configure} (but more on that later).

You see what the whole story adds up to: bootstrapping is using the
Autotools to convert the non-portable input files into an equivalent
portable form. The only two things that the user is required to have
are a Bourne shell, some associated programs like @command{sed}, and a
reasonable incantation of the @command{make} program. All these are
available on every Unix or Unix-like system since about 20 years now.

Having all that said, here's how we bootstrap.

@example
@group

$ pwd
/home/jfasch/work/wx-utils
$ aclocal -I /home/jfasch/confix/ac-m4 \
          -I /home/jfasch/confix/ac-m4/autoconf-archive/C++_Support
$ autoheader
$ automake --foreign --add-missing --copy

@end group
@end example

An alternative (and more comfortable) way of bootstrapping a package
is integrated into Confix. The following command does exactly the
steps we have performed so far - instrumenting and bootstrapping.

@example
$ confix.py --prefix=/home/jfasch/installed-packages --bootstrap
@end example

By the way, the Python @code{getopt} module recognizes option
prefixes, as long as the prefix is unique. @option{boo} is a unique
prefix of @option{bootstrap}, so you can save keystrokes and just yell

@example
$ confix.py --prefix=/home/jfasch/installed-packages --boo
@end example

@cindex @command{configure}
Here's how the package looks like after bootstrapping, with some
irrelevant parts omitted (Autoconf maintains some cache structures in
the hierachy, but these add nothing to the big picture). As explained
above, what's new is the shell script @file{configure} and the
@file{Makefile.in} files in the package root and the module
subdirectories. Apart from these primary files, Autoconf created a few
other files which are used during the build process in the next
section.

@example
@group
wx-utils
|-- Makefile.am
|-- Makefile.in
|-- Makefile.py
|-- aclocal.m4
|-- config.guess
|-- config.h.in
|-- config.sub
|-- configure
|-- configure.in
|-- depcomp
|-- install-sh
|-- ltmain.sh
|-- missing
|-- mkinstalldirs
|-- stamp-h.in
|-- bin
|   |-- Makefile.am
|   |-- Makefile.in
|   |-- Makefile.py
|   |-- crypt.cc
|   `-- wx-utils_bin.py
|-- check
|   |-- Makefile.am
|   |-- Makefile.in
|   |-- Makefile.py
|   |-- _check_debug_parse_levels.cc
|   `-- wx-utils_check.py
|-- code
|   |-- Makefile.am
|   |-- Makefile.in
|   |-- Makefile.py
|   |-- debug.cc
|   |-- debug.h
|   |-- linkassert.h
|   `-- wx-utils_code.py
|-- crypt
|   |-- Makefile.am
|   |-- Makefile.in
|   |-- Makefile.py
|   |-- crypt.cc
|   |-- crypt.h
|   `-- wx-utils_crypt.py
|-- error
|   |-- Makefile.am
|   |-- Makefile.in
|   |-- Makefile.py
|   |-- error.cc
|   |-- error.h
|   `-- wx-utils_error.py
`-- ext-crypt
    |-- Makefile.am
    |-- Makefile.in
    |-- Makefile.py
    `-- wx-utils_ext-crypt.py
@end group
@end example


@node The Configuration File (Short Introduction), Building the Package, Bootstrapping the Package, An Example
@comment  node-name,  next,  previous,  up
@section The Configuration File (Short Introduction)

@cindex configuration file
@cindex @file{.confix}
We noticed (at least) one annoying thing. Everytime we called Confix
we had to specify that @option{--prefix} option. You will be using
Confix more than once during package maintenance, and I bet you will
want to have a way to get around this. This is the time to give a
short introduction to the configuration file. (See @ref{The
Configuration File} for a more thorough explanation of the
configuration file and a list of all the settings available.)


At startup, Confix reads a file called @file{.confix} in your home
directory@footnote{You can specify a different file using the
@option{--configfile=} option.}. For our purposes the following simple
configuration file suffices.

@example
@group

myconfig = @{
    'PREFIX': '/home/jfasch/installed-packages',
    'BUILDROOT': '/home/jfasch/tmp/build'
@}

PROFILES = @{
    'default': myconfig,
    'myownconfig': myconfig
@}

@end group
@end example

@cindex Python
@cindex profile, configuration
@cindex configuration profile
@cindex @var{PROFILES}, @file{.confix}
@cindex @var{BUILDROOT}, @file{.confix}
@cindex @var{PREFIX}, @file{.confix}
This file is nothing but a Python script, it's just that it is not
executed by the Python interpreter directly, but rather by Confix
itself. You can put any code you like in it, but most of the time it
will be enough to define one or more @emph{profiles}. A profile is a
set of parameters and settings which are valid for one Confix
session. Profiles are made visible to Confix through the global
@code{PROFILES} dictionary. The user selects a particular profile
through the @option{--profile} option, for example

@example
confix.py --profile=myownconfig --boo
@end example

or just 

@example
confix.py --boo
@end example

because '@code{default}' is the name of the default profile, and that
entry in the @code{PROFILES} dictionary is set up to point to the same
profile as '@code{myownconfig}'.

That's enough explanation for the time being. The only settings we are
interested in so far are '@code{PREFIX}' and '@code{BUILDROOT}'. (We
haven't got around to using '@code{BUILDROOT}' yet, but we will so
soon.)

Now that we have got rid of the @option{--prefix} parameter, let's
continue with our package.

@node Building the Package, Installing the Package, The Configuration File (Short Introduction), An Example
@comment  node-name,  next,  previous,  up
@section Building the Package

@cindex building a package
@cindex package maintainer
@cindex package user
So far, until now, we have performed the job of the package
@emph{maintainer}. We used Confix to write Autotools input for us, and
used the Autotools to create a @command{configure} script for the
user. Now let's switch our mode and become the @emph{user} of our own
package. You probably have compiled an open source package before and
have already performed the @command{configure; make; make install}
dance. That's what we will be doing in this section.

Before we begin, let us state one important issue: @emph{we never
build in the source directory}. Rather, the build directory is a
distinct directory. Through this policy we can place the sources in a
directory which is subject to nightly backup, or on a RAID system, or
both, for example, whereas the build directory can be placed in a
location which is much cheaper. The build directory contains only data
which are easily reconstructed from the source, so it is unnecessary
to have it backed up.

@cindex @command{configure}
Now here we go. We create the build directory, chdir to that
directory, call @command{configure} (in the package root), and then
@command{make}.

@example
@group

$ mkdir -p ~/tmp/build/wx-utils
$ cd ~/tmp/build/wx-utils
$ /home/jfasch/work/wx-utils/configure \
         --prefix=/home/jfasch/installed-packages
$ make

@end group
@end example

(@command{configure} and @command{make} generate lots of messages to
standard error, we omit them for clarity.)

@cindex @option{--prefix}
@cindex module description file
@cindex description file, module
@cindex repository, of module description files
Notice the usage of the @option{--prefix} option here. We passed that
option to Confix when we were instrumenting the package; its purpose
there was to point Confix to module description file of other packages
that the @code{wx-utils} packages eventually depends on. The meaning of
the @option{--prefix} option with @command{configure} is a bit
different, albeit related. The prefix is the location the package will
get installed to (we will cover installation in the next section). The
relation to the module description files is that installing a package
involves installing the module description files into a location
called the @emph{module description repository}. (Remember how we
generated the module description files in @ref{Instrumenting the
Package}.) Finally, installed module description files are used by
Confix when it instruments a package.

As always, there is a simpler way to do this. Confix can start
@command{configure} and @command{make} for you. From the package root,
call

@example
$ pwd
/home/jfasch/work/wx-utils
$ confix.py --builddir=/home/jfasch/tmp/build/wx-utils --configure
@end example

or alternatively, from anywhere you want,

@example
$ confix.py --packageroot=/home/jfasch/work/wx-utils \
         --builddir=/home/jfasch/tmp/build/wx-utils \
         --configure
@end example

@cindex @var{BUILDROOT}, @file{.confix}
I admit that this is not much simpler than calling @command{configure}
by hand. But recall that we have set the '@code{BUILDROOT}' variable
in the configuration file to @file{/home/jfasch/tmp/build}. The effect
of this setting is that Confix assumes the package's build directory
is a subdirectory @file{wx-utils} of @file{/home/jfasch/tmp/build}
(@file{wx-utils} is the basename of the package root, that's how Confix
determines the name).

With this you can say,

@example
$ confix.py --configure
@end example

It's exactly the same with @command{make}, you just say

@example
$ confix.py --make
@end example

or eventually, the equivalent of calling @command{make -k},

@cindex @option{--targets}
@example
$ confix.py --make --targets=-k
@end example

Put realistically, after a while of using Confix you will just end up
using the following power user composite command,

@example
$ confix.py --boo --configu --make --targ=-k
@end example

@cindex Emacs, @var{compile-command}
@cindex @var{compile-command}, in Emacs
which instruments the package, bootstraps it, configures and builds it
in one big swoop. You will even set your Emacs @var{compile-command}
variable to something like

@example
$ confix.py --packageroot=/home/jfasch/work/wx-utils \
            --boo --configu --make --targ=-k
@end example

(Note that it is not necessary to re-bootstrap and re-configure a
package if you only want to compile it. Emacs gives you a chance to
edit the command before it is executed, and remembers the last billion
or so of commands you executed. So what I do at this point is to
remove @code{--boo} and @code{--configu} if I only want to compile.)

@node Installing the Package, Distributing the Package, Building the Package, An Example
@comment  node-name,  next,  previous,  up
@section Installing the Package

Package installation is simple,

@example
$ pwd
/home/jfasch/tmp/build/wx-utils
$ make install
@end example

or, alternatively, with the current working directory anywhere you
want,

@example
$ confix.py --packageroot=/home/jfasch/work/wx-utils \
            --make --targets=install
@end example

@cindex installation, of header files
@cindex installation, of libraries
@cindex header files
This copies all files which should be visible to other code to the
installation directory under @file{$(prefix)} (as given by
@command{configure --prefix=<prefix>}). Which files are visible after
installation is determined by Confix according to several rules which
are explained in @ref{Installation --- Going Public}. For example, if
a particular module is a C or C++ library, then that library is be
installed into @file{$(prefix)/lib}. Typically, a library is
accompanied by one or more header files; these are installed into
@file{$(prefix)/include}, or subdirectories thereof.

@cindex module description file
@cindex description file, module
@cindex repository, of module description files
One point to note here, again, is that installation covers module
description files as well. These files are installed in a subdirectory
@file{repo} of the installation directory, the module description
repository. (It is important that Confix users be aware of that fact
because the repository is a concept which is central to the inner
workings of Confix, as will be explained in @ref{Module Repository ---
Inter-Package Knowledge Transfer}.)

@node Distributing the Package, Summary, Installing the Package, An Example
@comment  node-name,  next,  previous,  up
@section Distributing the Package

So far we covered the life cycle of our test package from its raw
source form to its installed incarnation. However this is not the only
way a package can be treated. Rather, this is only the way the
package's maintainer uses to write, build and test his package.

@cindex open source
If you ever compiled an open source package, then you probably have
taken the following steps.

@enumerate

@item
Download the source distribution from the Internet, likely in
compressed form, as a @file{.tar.gz} file.

@item
Unpack it, thereby creating the source tree rooted by the
@emph{package root}.

@item
Create a separate package build directory, chdir to that directory,
and call @command{configure}, @command{make}, and @command{make
install}.

@end enumerate

So how do these steps correspond to the maintainer's steps which were
described in this chapter? Actually, the package user performs a
subset of the maintainer's work. Remember the explanation in
@ref{Bootstrapping the Package}, where we pointed out that the user is
by no means required to have the Autotools available. Bootstrapping is
the point after which the package user's work and the maintainer's
work are the same. @command{configure; make; make install}.

What is still unclear is how the source distribution is made. Clearly
this is not done by hand, as this job is tedious and error
prone. Automake implements a set of makefile targets for this,

@itemize @bullet

@item
@code{dist} creates a @file{.tar.gz} distribution.

@item
@code{dist-bzip2} creates a @file{.tar.bz2} distribution.

@item
@code{dist-zip} create a zip file (popular on Windows).

@item
@code{dist-tarZ} creates an old-style @file{.tar.Z} distribution.

@end itemize

@cindex @command{make dist}
Consult the Automake documentation for details about the various dist
targets and how they work in detail. For example, to create a source
distribution of our @code{wx-utils} package, we call

@example
$ pwd
/home/jfasch/tmp/build/wx-utils
$ make dist
@end example

or, through Confix,

@example
$ confix.py --make --targets=dist
@end example

@cindex package name
This will create the distribution tar file in the package's build
directory. The resulting distribution file's name has the form
@file{<packagename>-<packageversion>.tar.gz}. Unless otherwise
specified, @file{<packagename>} is the name of the package root
directory, and @file{<packageversion>} is 0.0.0. For example, if we
made a source distribution from our @file{wx-utils} package, the file
name would be @file{wx-utils-0.0.0.tar.gz}. See @ref{The Toplevel
Makefile.py Interface} for ways to specify the package name and
version.

@node Summary,  , Distributing the Package, An Example
@comment  node-name,  next,  previous,  up
@section Summary

In this chapter we have primarily learned about what you have to do
when you are a @emph{package maintainer}, and how Confix helps you do
your job. We also covered shortly the role of the @emph{package
user}. We also touched a few concepts involved: @emph{dependency
calculation} and the @emph{module description files}.

We presented lots of command lines as well as one helpful feature, the
configuration file. Here's a recap of the most important commands we
saw. (We assume a @file{.confix} file with contents about as in
@ref{The Configuration File (Short Introduction)}.)

@itemize @bullet

@item
@emph{Bootstrap.} This is the process of instrumenting the package and
generating all the files which are necessary for the end user.

@example
$ confix.py --bootstrap
@end example

in the package root directory, or, as always,

@example
$ confix.py --packageroot=/home/jfasch/work/wx-utils \
        --bootstrap
@end example

in any directory.

@item
@emph{Configure.} Preparing the package for the ultimate
build. Performing checks and creating a @file{Makefile} in every
directory of the package.

@example
$ confix.py --configure
@end example

@item
@emph{Make, Install.} Compiling the package and installing it.

@example
$ confix.py --make
@end example

or

@example
$ confix.py --make --targets=-k
@end example

or

@example
$ confix.py --make --targets='-k install'
@end example

or, without Confix, in the package build directory,

@example
$ make install
@end example

@end itemize

@node How Confix Works, The Coders Role in the Build Process, An Example, Top
@comment  node-name,  next,  previous,  up
@chapter How Confix Works

This chapter gives an overview of the concepts involved. It describes
each step Confix takes when it instruments a package. The description
may look more technical than necessary to you. But, on the other hand,
I am quite certain that it is easier for the user to understand the
rest of the manual if the concepts are clear from the
beginning. Confix offers an increasing range of possibilities where
the user can hook in to influence the build process. To fully utilize
this flexibility, it is crucial to understand how Confix works.

Don't be scared though, we only scratch the surface here. The details
are buried in the appendixes which you can consult if there is need
to. (If the appendixes do not contain enough material to satisfy you,
then I haven't yet found time to do it right. Complain to me, or
continue to ask questions, in either case the probability increases
that I write it down.)

@menu
* Scanning --- Gathering the Pieces::  
* Resolving --- Determining the Build Order::  
* Checks --- The Autoconf Way of Portability::  
* Module Repository --- Inter-Package Knowledge Transfer::  
@end menu

@node Scanning --- Gathering the Pieces, Resolving --- Determining the Build Order, How Confix Works, How Confix Works
@comment  node-name,  next,  previous,  up
@section Scanning --- Gathering the Pieces

Before Confix can instrument a package it must first determine the
modules which have to be instrumented, and the @emph{properties} of
these modules.

We saw in the example in the preceding chapter that Confix traverses
the package beginning at the package root. It examines every directory
on the way, and if that directory contains a @file{Makefile.py} file,
the directory is considered a module of the package and is remembered
for later instrumentation. (See @ref{The Module Makefile.py Interface}
for a detailed explanation of what that file can contain.)

Once @file{Makefile.py} is found in a directory, Confix further
examines this directory by interpreting its @file{Makefile.py}, and by
examining the directory at the file system level (i.e., looking what
files it contains). From this, the module's properties are
determined. Properties include such things as

@itemize @bullet

@item
@cindex buildable
@emph{Buildable} objects. Confix uses these to generate build
instructions for anything that can be built. For example, there is one
buildable object for every C++ source file in a module; the same holds
for other file types, such as C source files, C header files, and Lex
and Yacc files. Apart from these buildable types that comprise single
source files, there are more complicated @emph{composite} buildable
types --- a library of compiled object files, for example, or an
executable.

Confix uses a great deal of heuristics to determine what has to be
built, and how@footnote{Remember, the primary goal of Confix is to
build most code automatically, without the package maintainer having
to write any build instructions, so that's the default behavior.}. For
example, if it finds out that a C or C++ source file contains the
@code{main()} function, then it concludes that the package maintainer
wants this file to become an executable, and links it with all other
files in the module that do not contain the @code{main()}
function. Contrariwise, if it finds that no source file of a module
contains @code{main()}, then it decides to build a library
instead. However, some of Confix's heuristics are a bit, well,
simplistic, and you need to help it a bit. See @ref{What Will Be
Built} for a more detailed explanation of Confix's heuristics, and how
to help out if something goes wrong.

@item
@cindex require
@cindex provide
@emph{Provide} and @emph{Require} objects. These important concepts
are central to computing the inter-module dependencies. A module A is
said to depend on another module B if module B @emph{provides}
something that module A @emph{requires}. For example, consider a file
@file{a.c} in module A which @code{#include}s a file @file{b.h} which
is located in module B. This is a situation where module A
@emph{requires} (through the @code{#include <b.h>} directive in its
@emph{buildable} file @file{a.c}) a file @file{b.h} which is
@emph{provided} by module B.

@*

@iftex
@image{prov-req}
@end iftex

@ifhtml
@image{prov-req}
@end ifhtml

@ifinfo
@c XXX
(Lacking image for info.)
@end ifinfo

In the remainder of this document, the words @emph{provide} and
@emph{require} will often be used as a noun. This is to clarify that
we mean the properties of a module which are the fundamentals of the
resolving process (which will be explained in the next section).

The fact that a buildable in module A contains @code{#include <b.h>}
is said to be @emph{a require}, whereas the fact that module B
contains @file{b.h} is said to be @emph{a provide}. The latter
satisfies --- @emph{resolves} --- the former, and thus module A is
said to @emph{depend} on module B.

@item
@cindex checks, Autoconf
@cindex Autoconf checks
@cindex contributing, to a module's properties
@cindex contributing checks
@emph{Checks}. One of the most basic albeit powerful features of
Autoconf is its ability to check the availability of certain features,
and to provide that information (available yes/no/what/how) to the
build process. Without Confix, these checks have to specified in the
@file{configure.in} file by the maintainer. With Confix, checks are
properties of modules and are mostly determined by the module's
buildable objects. See @ref{Checks --- The Autoconf Way of Portability}
further down in this chapter for more about checks, and @ref{Module
Repository --- Inter-Package Knowledge Transfer} for how Confix carries
checks across package boundaries.

@item
@emph{Module content}. A module content is an object that describes
what another module has to do if it uses this module. For example, the
@emph{content} of a module whose outcome is a C library describes to a
using module what the name of the library is and what include path
must be set to find the library's accompanying header files.

@end itemize

So much for the internal structures of Confix. Sure there is more to
it, but this is beyond the scope of this manual. However, if you are
interested: it is actually implemented this way, and you should easily
be able to find the associated Python classes by using something like
@command{grep -i} in the source code.

@node Resolving --- Determining the Build Order, Checks --- The Autoconf Way of Portability, Scanning --- Gathering the Pieces, How Confix Works
@comment  node-name,  next,  previous,  up
@section Resolving --- Determining the Build Order

@cindex dependency graph
@cindex dependency resolving
@cindex resolving, dependencies
Resolving is the task of building a directed acyclic graph of modules,
the @emph{dependency graph}. In the preceding section we saw an
example which detailed the concept of @emph{provide} and
@emph{require} and what these have to do with module
dependencies. According to this example, if the modules A and B are
nodes in the dependency graph, then a graph edge leads from A to B if
(and only if) A depends on B.

Confix builds this dependency graph by matching the @emph{requires} of
all modules against the @emph{provides} of all modules. If a require
of module A is matched (resolved) by a provide of module B, then we
have an edge from A to B in the graph.

@cindex module description file
@cindex description file, module
@cindex repository, of module description files
Note that the resolving process is not local to the package that is
being instrumented. A module of the package may require something that
is not provided locally, but rather by a module of another
package. How can this dependency be resolved? Recall how we came
across the module description files and the module repository multiple
times in this manual (an indication that it must somehow be central to
Confix). It's these repository files that carry the information what
items an installed module provides and requires. When Confix builds
the dependency graph, it not only determines the properties of the
modules in this package, but also reads the module description
repository@footnote{By default the repository is @file{$(prefix)/repo},
see also the description of @option{--repository} in @ref{Options and
Parameters}} to determine the properties of installed modules.

Now what has a dependency graph to do with building a package? The
answer is @emph{build order}. For example, consider our example
@file{wx-utils} package from the preceding chapter. There is a module
called @file{bin} which contains executables. On of these, built from
the source file @file{crypt.cc}, is a simple program which accept two
arguments from the commandline and passes these to the
@code{WX::Utils::Crypt::crypt()} method, which is defined in the
@file{crypt} module of the @file{wx-utils} package. Through this
relationship, we say that module @file{bin} depends on module
@file{crypt}.

Confix sees dependencies through the occurence of include directives
in source files. @file{bin/crypt.cc} contains a line @code{#include
<WX/Utils/crypt.h>} --- in other words, module @file{bin}
@emph{requires} a file @file{WX/Utils/indent.h}. On the other hand,
the module @code{crypt} contains a file @file{crypt.h} which is
@emph{provided} as @file{WX/Utils/crypt.h}@footnote{Confix implements
a relationship between C++ namespaces and include directories, see
@ref{The Coders Role in the Build Process} for further explanation.}

Now consider what happens if module @file{bin} was built before module
@file{crypt}. @file{bin} contains a C++ executable, with the
@code{main()} routine in @file{bin/crypt.cc}. This executable contains
a reference to a routine @code{WX::Utils::Crypt::crypt()} which is
defined in @file{crypt/crypt.cc}. When it comes to linking the
executable, the linker will try to satisfy that reference, which it
cannot because module @file{crypt} has not yet been built.

Hence, module @file{crypt} must be built before @file{bin}. Confix
ensures this by examining the dependency graph and calculating a
correct build order from it@footnote{The process of flattening a
directed acyclic graph (DAG) this way is commonly called
@emph{topological sort}.}. Dependency cycles (see @ref{Build Order ---
How Things Can Easily Go Wrong}) are clearly an error; this error is
detected by Confix, and reasonable messages are output so that the
user will be able to break up the cycle.

@node Checks --- The Autoconf Way of Portability, Module Repository --- Inter-Package Knowledge Transfer, Resolving --- Determining the Build Order, How Confix Works
@comment  node-name,  next,  previous,  up
@section Checks --- The Autoconf Way of Portability

One approach to cross-platform portability is to wrap platform
dependent code in @code{#ifdef}s, and to create an if-then-else ladder
where you switch across architectures like this,

@example
@group
#ifdef Solaris
// Solaris code here
#elif (defined Linux)
// Linux code here
#elif 
// blah
#endif
@end group
@end example

Autoconf's (and, as Confix sits on top of it, Confix's) approach to
portability is a bit different. It checks for features instead of for
architectures, so that you do not anymore switch across architectures,
but rather react on the presence or non-presence of features. Autoconf
and Automake provide a bunch of so-called @emph{checks}: M4 macros
which expand to Bourne shell code. What they do is best explained with
an example.

A C++ file (which is buildable object) certainly requires the
availability of a C++ compiler. So, the buildable automatically
contributes the appropriate Autoconf check to its enclosing
module. Confix takes care that all checks gathered this way be written
to the @file{configure.in} file in the package root, as if the
maintainer had written them.

The effect of this check is seen when the user calls
@command{configure}. The @command{configure} script executes code that
tries out several things, such as looking if the @env{CXX} environment
variable is set, checking if it points to a valid executable, checking
if that executable can be used as a C++ compiler, what the flags and
options are that have to be passed to that compiler to function
properly, and so on. The effect of this particular check is that some
well-defined @command{sh} variables are set for further use in
@command{configure}, that code is generated to substitute specific
patterns in the various @file{Makefile.in}'s in the package tree, and
so on. As for @command{sh} variables: C++ specific checks need them to
be able to call the appopriate compiler to perform their work. For
example, a check that determines if @code{stringstream} is available
and works correctly (sigh!) needs to generate code that uses
@code{stringstream}, and then call the C++ compiler to compile and
eventually link the program.

@cindex ordering, of Autoconf checks
@cindex checks, ordering of
This leads us to another feature of Confix@footnote{If you consider
eliminating duplicate checks a feature: yes, this is done. Else we
would check for a C++ compiler as many times as there are C++ files in
a package, for example.} associated with Autoconf checks: it respects
ordering of checks. For example, the check for the C++ compiler has to
be performed before a check for a particular language feature, such as
the @code{stringstream} class.

Checks are not only contributed implicitly. There are several ways
that checks can be contributed explicitly by the maintainer. See
@ref{Explicitly Adding Checks}, @ref{The Toplevel Makefile.py
Interface}, @ref{The Module Makefile.py Interface}, and @ref{The
Buildable Interface} for various ways to explicitly add
checks@footnote{An example can be found in the @file{wx-utils} package,
file @file{error/error.cc}.}.

See also @ref{Module Repository --- Inter-Package Knowledge Transfer} how
the build process of one module is automatically crafted to perform
all checks of all installed modules it uses.

@node Module Repository --- Inter-Package Knowledge Transfer,  , Checks --- The Autoconf Way of Portability, How Confix Works
@comment  node-name,  next,  previous,  up
@section Module Repository --- Inter-Package Knowledge Transfer

Suppose that you are in the situation where you have, say, ten
installed packages which amount to twenty or so libraries. You are
writing an executable which directly uses features from three of these
libraries, and carefully craft your link line to contain these three
libraries. Most likely this is not enough because one of these
libraries is not self-contained --- it depends on another four
libraries. And so on.

@cindex module description file
@cindex description file, module
@cindex repository, of module description files
Without Confix, you'd have to explicitly know about these
dependencies, and hand-craft your link lines and include paths
accordingly. Confix's process of computing a correct build order has
already been outlined in @ref{Resolving --- Determining the Build
Order}. There we pointed out that computing the build order involves
topologically sorting the dependency graph. Now, that graph does not
only contain modules which are local to the package, but also those
modules which have been installed --- whose module description files
are available in the module repository. In other words, the graph
presents a global view of module dependencies.

@cindex include path
@cindex link line
@cindex build order
So, a topologically sorted list of the graph's nodes (the modules)
gives enough information to compute the following important items.

@itemize @bullet

@item
A correct build order. Only the modules of the current package must be
taken, of course, as it doesn't make any sense to build an installed
module.

@item
A correct include path.

@item
A correct link line.

@end itemize

This is only one example (although the most important) of how Confix
coordinates packages and their modules. Autoconf checks are another
example.

@cindex Autoconf checks
@cindex checks, Autoconf
Say one module (a C or C++ library, as always) performs a check for,
say, the availability of the JPEG library. That library is not
maintained by Confix, but rather part of the Linux distribution (they
don't manage their stuff with Confix yet). This check succeeds, and
the module ends up referencing a function which is defined in the JPEG
library. The check not only checked for the availability, but also set
a @command{sh} variable that contains the name of the library. This
variable normally has to be put on the link line of an executable so
that the library is seen by the linker and the symbol can be resolved.

Now, sadly, the check is only performed locally, in the package that
contains the module that directly uses the JPEG library. Any
executable, of another package, that uses that module will get a
linker error because it does not perform the same check (and thus does
not add the JPEG library to the link line).

@cindex module description file
@cindex description file, module
@cindex repository, of module description files
Here's where Confix and its module description repository helps
again. Autoconf checks are @emph{properties of the module} and thus
show up in the module description file which is read by
Confix. Whenever a module uses another module, Confix automatically
arranges that it performs all the checks of that module.

@node The Coders Role in the Build Process, The Users Role in the Build Process, How Confix Works, Top
@comment  node-name,  next,  previous,  up
@chapter The Coder's Role in the Build Process

@cindex automatisms, and flexibility
@cindex rule, restrictions, for the maintainer
@cindex restrictions, imposed on the maintainer
One of the advantages of Confix is that you are not required to write
any explicit build instructions to control the build process of a
package and its modules. Confix tries to determine everything it needs
to know from the files it has to write build instructions
for. However, nothing is for free. Automatisms generally tend to cut
down flexibility of the underlying mechanisms, and unfortunately
Confix is not an exception to this. Confix imposes a few rules on the
package maintainer, and for sure you cannot do everything you could do
if you used the Autotools directly@footnote{You can use the
@code{MAKEFILE_AM()} function in a module's @file{Makefile.py} to pass
arbitrary code through to the generated @file{Makefile.am}, but this
should be used with care.}. But read on to get a better judgement.

In this section we will explain basic properties of the build process,
mainly by outlining how Confix works. As opposed to the previous
section, @ref{How Confix Works} (where we explained how Confix works),
in this chapter we will put more focus on the package maintainer. We
will try to make clear what the relevant package properties are, and
how the maintainer can/should direct Confix to best determine
these. Most of the package's build properties can be explicitly
configured by the maintainer. However, this chapter deals with the
properties and the involved automatisms Confix implements, and refers
to @ref{Interfaces for Coder and Maintainer} otherwise. The chapter is
a bit lengthy as it goes to technical details whenever I feel that I
need to justify why a particular restriction is the way it is. If you
are curious, I suggest you read the chapter. If you are impatient, I
suggest you only read the summary at the end of the chapter
(@ref{Summary of Rules and Restrictions}) and uncritically accept what
is there.

To get an overview, here are some of the package properties we will be
talking about.

@itemize @bullet

@item
@emph{What files will be built.} Just like the Autotools, Confix uses
file extensions for its decision what is built and how.

@item
@cindex installation location
@cindex install directory
@emph{Installation locations.} It makes sense to install header files
(for example) into subdirectories of the public
@file{$(prefix)/include} directory, primarily to prevent file name
clashes when several packages are installed in the same location.

@item
@cindex build order
@cindex order, of build
@emph{Build order.} We have touched this several times --- the
maintainer implicitly specifies the build order through
@emph{provides} and @emph{requires}.

@item
@emph{What is public, what is private?} For example, you may have
header files which are only used during build, whereas others should
be made publicly available by installing them.

@item
@emph{Checks.} Confix provides various ways for the maintainer to add
Autoconf checks to the build process.

@comment FIXME: what else

@end itemize

Further, we will mostly be talking about C and C++ in this chapter
because these are the only languages which are supported at the time
of this writing@footnote{This is Nov, 2002.}. The chapter will get
deeper structure as other languages arrive.

@menu
* What Will Be Built::          
* Installation --- Going Public::  
* Build Order --- How Things Can Easily Go Wrong::  
* Explicitly Adding Checks::    
* Performing Automatic Tests::  
* Using Third Party Libraries::  
* Restrictions Imposed on the Package Structure::  
* Using GNU Libtool::           
* Summary of Rules and Restrictions::  
@end menu

@node What Will Be Built, Installation --- Going Public, The Coders Role in the Build Process, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section What Will Be Built, and How

@cindex compiling source files
@cindex archive
@cindex static library
@cindex shared library
@cindex library, static
@cindex library, shared
@cindex executable
Building C@footnote{When we talk about C, we do not only mean plain C,
but also related languages like C++, or even Lex and Yacc which are
built by Automake just like C.} code is usually done in several
steps. First, source files are compiled into object files. Then,
object files are grouped together to form some kind of compound
object. One example of a compound object (the simplest) is an
@emph{archive}, also known as @emph{static library}. Another form of a
compound object is a @emph{shared library}, which is similar to a
static library, but not quite@footnote{See @ref{Using GNU Libtool} for
a more thorough explanation of what shared libraries are and how to
build them with Confix.}. The incarnation of a compound object that
most computer users know is an @emph{executable}.

The following section describes how Confix decides how source code is
built, and how to group the compiled object files into compound
objects.

@menu
* Building Source Files::       
* Library or Executables?::     
* Generated and Explicit Names::  
@end menu

@node Building Source Files, Library or Executables?, What Will Be Built, What Will Be Built
@comment  node-name,  next,  previous,  up
@subsection Building Source Files

@cindex filenames
@cindex file suffixes
@cindex suffixes, of filenames
@cindex extension, of filenames
From the file names in a directory, Confix determines what source
files should be built. If a directory contains files which boil down
to compiled object code, Confix assumes that either a library or one
or more executables will be built. (See below for heuristics that help
Confix decide which.)  Confix uses much of the Autotools functionality
to accomplish the task of building object code.

The Autotools recognize several filename extensions and generate
@command{make} rules accordingly, and so does Confix. Currently, the
file extensions recognized are

@itemize @bullet
@item 
@cindex C
@code{.c}: Plain C code

@item
@cindex C++
@code{.cc},@code{.cpp}: C++ code

@item
@cindex Lex
@code{.l}: @code{lex}, generating C code. Autoconf will determine the
@code{lex} derivative, so you may end up compiling with @code{flex}
under the hood, for example.

@item 
@cindex Lex, and C++
@code{.ll}: @code{lex}, generating C++ code. @emph{Note} that you may
encounter portability problems if you are using this feature because
not every @code{lex} version on every platform will be capable of
generating C++ output. You will then have to force your users to
install one @code{lex} version that is capable of that. The
alternative is to accept that @code{lex} is somewhat, well, stupid,
and assume that the user's @code{lex} version can do no more than K&R
C, and name your @code{lex} files @code{.l}. @emph{Note} also that
there is no general advice as to which @code{lex} version or
derivative your code is best compiled with. This topic is completely
left to Autoconf which will determine the version --- proper or
improper.

@item 
@cindex Yacc
@code{.y}: @code{yacc}, generating C code. Again Automake determines
the derivative and reacts properly.

@item 
@cindex Yacc, and C++
@code{.yy}: generating C++ code. Same problem as with @code{lex}.

@end itemize

By default, unless stated otherwise, Confix tries to build every file
in a directory that it recognizes. Sometimes however you want to keep
source files in a directory that you do not want to have built,
probably because they do not compile yet. You can tell Confix to
ignore these files; see the @code{IGNORE_FILE()} function in @ref{The
Module Makefile.py Interface}.

@node Library or Executables?, Generated and Explicit Names, Building Source Files, What Will Be Built
@comment  node-name,  next,  previous,  up
@subsection Library or Executables?

@cindex properties, of source files
@cindex source file properties
Before Confix can generate build instructions for compound objects, it
has to decide which compound object(s) should be built. Recall section
@ref{Scanning --- Gathering the Pieces} where we explained the concept
of @emph{buildable objects} for single files.  Internally, every
source file is wrapped into a (Python language) object which is
responsible for generating build instructions for that file. Another
responsibility of a single-file buildable object of C language type is
to maintain a certain property that tells Confix whether the source
file contains the @code{main()} function.

@cindex static library
@cindex shared library
@cindex Libtool

@itemize @bullet

@item
@emph{Library}. Confix puts all compiled files of the module together
into a library if none of the source files has the @code{main()}
funtion defined. By default, Confix generates a static library; see
@ref{Using GNU Libtool} for explanation of how to build shared
libraries.

@item
@emph{Executable(s)}. If any of the files has @code{main()} defined,
Confix divides the files of the module in two groups: those which have
@code{main()} and those which don't. Every file that has @code{main()}
becomes an executable, and it is linked together with those files that
don't have @code{main()}.

@end itemize

@vindex MAIN, source file property
@findex MAIN, buildable interface
@findex FILE_PROPERTIES
So how does Confix determine this ``have the @code{main()} function''
property? It scans every source file and employs a simple minded
parser to search for patterns that look like as if they were the
definition of @code{main()}. But this parser is not a real C/C++
parser, and it is likely to produce false results. Mostly it will see
a @code{main()} definition where there is none, rather than the other
way around. If this is the case, you'll probably see a linker error
message that tries to tell you that linking failed because @code{main}
is undefined. You then have two choices; either search in the
offending source file for occurences of @code{main} and change them to
@code{primary} or something; or you use one of the Confix interfaces
to explicitly set the source file's @code{'MAIN'} property to tell
Confix that there's no @code{main()} in the file@footnote{A third
choice is to complain to the author by filing a bug report (which you
should do even if you take one of the two former choices).}. See the
@code{MAIN()} and @code{FILE_PROPERTIES()} functions described in
@ref{The Buildable Interface}, or the @code{FILE_PROPERTIES()}
function described in @ref{The Module Makefile.py Interface} for ways
to influence Confix in this respect.


@menu
* Generated and Explicit Names::  
@end menu

@node Generated and Explicit Names,  , Library or Executables?, What Will Be Built
@comment  node-name,  next,  previous,  up
@subsection Generated and Explicit Names

@cindex name, of an executable
@cindex executable name
@vindex EXENAME, source file property
@findex EXENAME, buildable interface
@findex FILE_PROPERTIES
@cindex name, of a library
@cindex library name
@vindex LIBNAME, module property
@findex LIBNAME, module interface
@findex MODULE_PROPERTIES
@cindex module properties
@cindex properties, of modules
Confix tries to generate instructions to successfully build a package,
ideally without any input from the package's maintainer. However, in
doing so, Confix tries to not bring the package in conflict with other
packages. It is likely that more than one package is installed in the
same location --- this is the common case (the default installation
prefix is @file{/usr/local}). Now, for example, consider that two
packages build executables, and that the names of two different
executables are equal. These two executables would overwrite each
other.

To prevent this situation, Confix does not simply take the name of the
source file that has the @code{main()} function defined, as this would
easily lead to the situation deescribed above. Rather, Confix
``mangles'' the name from the package name, the module name, and the
source file name. While this is ok for test programs that are run
automatically (see @ref{Performing Automatic Tests} for more), you
probably want to explicitly specify a name for these executables that
you want to make visible to users. To do this, you set the
@code{'EXENAME'} source file property; see the @code{EXENAME()} and
@code{FILE_PROPERTIES()} functions described in @ref{The Buildable
Interface}, or the @code{FILE_PROPERTIES()} function described in
@ref{The Module Makefile.py Interface}.

@cindex module properties
@cindex properties, of modules
@findex LIBNAME
@vindex LIBNAME
@findex MODULE_PROPERTIES
A similar conflict could happen with libraries, and Confix solves this
problem the same way. Mangled library names are not normally a problem
for the user because Confix recognizes module dependencies and
generates link lines automatically. However, until Confix achieves
world domination, it is likely that the libraries that are built by
Confix are used by code that is not built by Confix@footnote{It is
even more likely that software which is built by Confix will use
software that is not built by Confix --- see @ref{Using Third Party
Libraries} for more.}. In this case you have to give your library a
publicly understandable name by using the @code{MODULE_PROPERTIES()}
or @code{LIBNAME()} functions described in @ref{The Module Makefile.py
Interface}.

@node Installation --- Going Public, Build Order --- How Things Can Easily Go Wrong, What Will Be Built, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Installation --- Going Public

@cindex installation location
@cindex install directory
One important part of build management is the installation
location. The Autotools are pretty clear about what goes where; they
state, for example, that header files go into
@file{$(prefix)/include}, libraries go into @file{$(prefix)/lib},
executables go into @file{$(prefix)/bin}, and so on.

There are more aspects of installation, two of which we will cover in
this section. First, you need a way to differentiate between files
which will go public and files which won't. Second, you may want to
put your header files into subdirectories of @file{$(prefix)/include}.

@menu
* What Goes Public::            
* Namespaces::                  
* Installation --- A Short Example::  
* Restrictions::                
@end menu

@node What Goes Public, Namespaces, Installation --- Going Public, Installation --- Going Public
@comment  node-name,  next,  previous,  up
@subsection What Goes Public

When you are building a library, you will most likely have header
files which you want to install along with that library. But, on the
other hand, you will likely have header files whose purpose is an
internal one, and which no-one needs anymore once the library is
built. You do not want these to be installed.

@cindex header files, installing
@cindex installing header files
@cindex header files, public
@cindex header files, private
@cindex public header files
@cindex private header files
To have Confix automatically differentiate between public and private
header files, you simply prefix the private files with an
underscore. Private files are then visible to modules within the same
package, but they don't get installed and thus are not visible to
modules from other packages.

@node Namespaces, Installation --- A Short Example, What Goes Public, Installation --- Going Public
@comment  node-name,  next,  previous,  up
@subsection Namespaces and @code{#include}

@cindex namespaces, and @code{#include}
@cindex guessing, installation directories from namespaces
In C and C++, one often has the problem that certain symbols in one
module conflict with symbols in modules of fellow developers. People
end up adding prefixes to their symbol names to make them unique,
which works but makes typing the names rather annoying. To help with
this, C++ namespaces were invented. You put all the names which would
otherwise have a common prefix into a namespace with that name
instead. This way you only need to keep namespace names unique which
is much easier.

A similar problem arises when all developers install their header
files to a common location. People have to keep header file names
unique, much like they have to keep symbol names unique in C.

While the former problem can be solved using namespaces, the latter
problem lacks a standard solution. Confix tries to solve it by
installing header files into @emph{subdirectories of} that common
location. These subdirectories are determined from namespaces that
occur in the file. For example, if a file @file{public.h} contains the
following,

@example
@group
namespace MyOwnCode @{
namespace MyLibrary @{

// ...

@} // /namespace
@} // /namespace
@end group
@end example

then Confix guesses that the file should be installed as
@file{MyOwnCode/MyLibrary/public.h}. @emph{Note} the terminating
comments which are vital to Confix as it is not a C++ parser. Other
modules will have to include this file with @code{#include
<MyOwnCode/MyLibrary/public.h>}. @emph{Note} that files in the same
directory still must include it with @code{#include "public.h"}
because at this time the file is not yet installed.

@node Installation --- A Short Example, Restrictions, Namespaces, Installation --- Going Public
@comment  node-name,  next,  previous,  up
@subsection Installation --- A Short Example

Here's a little example that demonstrates the issues outlined
above. The package contains a module @code{my_library} which builds a
library. The library's interface is inside the C++ namespace
@code{MyLibrary} which is itself inside a namespace @code{MyOwnCode},
and it is defined in a public header file @file{public.h}. During the
build process of the module a second header file @file{_private.h} is
used, but this header file is not part of the interface and thus must
not be installed.

The source tree layout is as follows.

@example
@group
<packageroot>
`-- my_library
    |-- Makefile.py
    |-- _private.h
    |-- impl.cc
    `-- public.h
@end group
@end example

The content of @file{public.h} is (note the @code{/namespace} marker)

@example
@group
#ifndef my_library_public_h
#define my_library_public_h

namespace MyOwnCode @{
namespace MyLibrary @{

// whatever interface definition

@} // /namespace
@} // /namespace

#endif
@end group
@end example

After bootstrapping, configuring, and installing the package, the
@file{$(prefix)} directory looks as follows,

@example
@group
$(prefix)
|-- include
|   `-- MyOwnCode
|       `-- MyLibrary
|           `-- public.h
|-- lib
|   `-- lib<packageroot>_my_library.a
`-- repo
    `-- <packageroot>_my_library.py
@end group
@end example

Note how the library interface @file{public.h} has been installed in a
hierarchy @file{MyOwnCode/MyLibrary} under the include directory. The
directory hierachy an exact mirror of the namespace hierarchy which is
defined in the module. Foreign code (and other modules from the same
package) that uses our library generally pulls in the definitions like
this

@example
#include <MyOwnCode/MyLibrary/public.h>
@end example

@node Restrictions,  , Installation --- A Short Example, Installation --- Going Public
@comment  node-name,  next,  previous,  up
@subsection Restrictions

@cindex restriction, namespace
One important restriction is imposed through this (and through the way
Automake lets the maintainer hook into the build process): @strong{you
can have only one namespace per directory}.

Why is this? Say you have a second interface definition for the
library, in a file @file{public2.h} in the same directory, which looks
as follows.

@example
@group
#ifndef my_library_public2_h
#define my_library_public2_h

#include "public.h"

namespace MyOwnCode @{
namespace MyLibrarySecond @{

// second interface definition

@} // /namespace
@} // /namespace

#endif
@end group
@end example

This file includes @file{public.h}. As that file is in the same
directory as @file{public2.h}, @file{public2.h} includes
@file{public.h} like @code{#include "public.h"}. However, due to the
different namespace hierarchies, the installed incarnation of the
interface definitions is spread into two directories, like

@example
@group
$(prefix)
`-- include
    `-- MyOwnCode
        |-- MyLibrary
        |   `-- public.h
        `-- MyLibrarySecond
            `-- public2.h
@end group
@end example

Now, consider user code that says,

@example
#include <MyOwnCode/MyLibrarySecond/public2.h>
@end example

This code will get a compilation error. The C preprocessor will
complain about the @code{#include "public.h"} in @file{public2.h}
which cannot be found. The include path generally only points in
@file{$(prefix)/include}, and never in any subdirectories
thereof. Hence, what works during compilation of the package, where
@file{public.h} and @file{public2.h} are in the same directory (even
with different namespaces), will cease to work for the installed case.

@findex INSTALLDIR_H
This restriction is not that stringent though. If for some reason you
are forced to have different namespaces in files that are in the same
directory, you can always disable the offending automatism. Edit the
@file{Makefile.py} in that directory, and specify the installation
location for all headerfiles in that directory. Say you want both
@file{public.h} and @file{public2.h} installed into the directory
@file{MyOwnCode/MyLibrary}, then you add the following to
@file{Makefile.py}.

@example
INSTALLDIR_H('MyOwnCode/MyLibrary')
@end example

@node Build Order --- How Things Can Easily Go Wrong, Explicitly Adding Checks, Installation --- Going Public, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Build Order --- How Things Can Easily Go Wrong

@cindex build order
@cindex order, of build
Confix uses requires and provides to match modules against each other,
and to compute a correct build order. Now what is a correct build
order? A formal definition could be, for example, ``If module A
depends on module B, then module B @emph{must not use any bit} of
module A''.

This may seem trivial, but if you think of it more deeply, you'd come
to the question, ``Why shouldn't module B @code{#include} header files
from module A? They are present all the time, even if module A is not
yet built.''. The latter is not quite true. Remember that we said
above that even modules within the same package must include another
module's include files as if they were foreign code. They have to
apply the full namespace-to-include-directory mapping, simply because
they must compile even after they have been installed (see the example
above, where @file{public.h} was included from another public header
file, @file{public2.h}). In the local case, however, this hierarchy is
not present, and big tricks are applied by Confix to to make that
constellation compile happily. These tricks are outside the scope of
this manual@footnote{For the curious: we utilize Automake's
@code{all-local} hook target to create the namespace hierarchy of
include directories inside the build directory, and point the other
module's include path there. Look for directories named @file{include}
under the package's build directory, after the package was compiled.},
suffice it to say that @emph{the include files are not present all the
time for all modules in a package}. Rather, a module has to be built
before its header files can be correctly included.

@cindex restriction, build order
@cindex build order, restriction
What follows is the restriction as stated above: @strong{If module A
depends on module B, then module B must not use any bit of module A}.

@node Explicitly Adding Checks, Performing Automatic Tests, Build Order --- How Things Can Easily Go Wrong, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Explicitly Adding Checks (and Programming with Them)

@cindex Autoconf checks
@cindex checks, Autoconf
@cindex checks, programming with
With stock Autoconf, you normally list checks in
@file{configure.in}. For example, if your code were using C++ string
streams, you'd run into problems getting it to compile with both a
pre-standard and a standard C++ compiler. To get around this, you'd
have to use conditional code. The Autoconf way for this is to check
for availability of one or the other, and to define the neessary
preprocessor macro accordingly. In our case, the check is is
@code{AC_CXX_HAVE_SSTREAM} (from the Autoconf macro archive which you
get with Confix), and the macro it defines is @code{HAVE_SSTREAM}.

With stock Autoconf, you'd write the check in @code{configure.in},

@example
@group
...
AC_CXX_HAVE_SSTREAM
...
@end group
@end example

Then, in the code, you react on what the check determined for you. In
particular, @code{AC_CXX_HAVE_SSTREAM} sets the HAVE_SSTREAM macro to
@code{1} if the standard C++ header file @file{<sstream>} is available
and defines @code{std::stringstream}, else the macro is left
undefined. Your code looks as follows@footnote{@code{HAVE_CONFIG_H} is
always defined and @code{1} when you use Confix, but it is good style
this way, I think.},

@example
@group
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#ifdef HAVE_SSTREAM
# include <sstream>
#else
# include <strstream.h>
#endif
@end group
@end example

@cindex checks, and Confix
One problem with this approach is that the check is placed in
@file{configure.in}, whereas the results of the check (in this case,
the @code{HAVE_SSTREAM} macro) are used in the various source files of
the package. You do not automatically correlate between these
locations. For example, if you change the source to not check
@code{HAVE_SSTREAM} for some reason (e.g., you do not use
@code{stringstream} anymore), you might want to consider removing the
check from @file{configure.in}. However, you cannot be sure that no
other source file in the package uses @code{HAVE_SSTREAM}, so you have
to grep over the package source to be sure. Or the other way around:
you remove your usage of @code{HAVE_SSTREAM} and don't care about the
check. The result is a bloated @file{configure.in} file with lots of
unnecessary checks, slowing down the build process.

The Confix approach, as always, is to determine from the source what
checks have to be applied. However, it cannot, for example, guess from
your usage of @code{HAVE_SSTREAM} that it must apply the check
@code{AC_CXX_HAVE_SSTREAM} --- this is, well, impossible. Confix
simply cannot know that @code{HAVE_SSTREAM} is the result of the check
@code{AC_CXX_HAVE_SSTREAM}@footnote{A check can have more side effects
than just defining one simple macro.}. The maintainer must direct
Confix to apply the right check. This is ok because the maintainer
usually knows about the effects of checks.

So, with Confix, you write code similar to above, but with one comment
line more.

@example
@group
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

// CONFIX:CHECK(AC_CXX_HAVE_SSTREAM())
#ifdef HAVE_SSTREAM
# include <sstream>
#else
# include <strstream.h>
#endif
@end group
@end example

@cindex interface, @emph{buildable}
@cindex @emph{buildable} interface
Note the comment line: it starts with @code{CONFIX:}, followed by an
instruction which adds the check @code{AC_CXX_HAVE_SSTREAM} to the
containing package@footnote{Implementation note: actually, the check
is added to the @emph{buildable} object which resembles the source
file. The @emph{buildable} object is managed by the enclosing
module. Confix arranges that all the necessary information arrives in
@file{configure.in}. In the end, our check makes its way from the
buildable object over the module object into the package object, which
then writes it into @file{configure.in}.}. Remember how we saw in
@ref{Checks --- The Autoconf Way of Portability} that Confix takes
care of the check's correct placement in @file{configure.in}, and of
its uniqueness there.

@cindex checks, and source code
@cindex source code, and checks
So much for adding checks in the source code. Generally, these comment
things are the @emph{interface} to the buildable objects which
resemble the respective source file. The part of the comment line
which reads ``@code{CHECK(AC_CXX_HAVE_SSTREAM())}'' is actually
nothing but Python code which calls a function @code{CHECK()} which is
defined as part of that interface, and which expects a check object as
a parameter. The ``@code{CONFIX:}'' prefix is C++ specific and marks
occurences of such interface utilization. See @ref{The Buildable
Interface} for a detailed description of the interface and a list of
what else you can write in source files.

@node Performing Automatic Tests, Using Third Party Libraries, Explicitly Adding Checks, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Performing Automatic Tests

@cindex testing, with Confix
@cindex automatic testing, with Confix
Automake provides support for automatically testing your code. All you
have to do is to write test programs (of arbitrary complexity) which
take no arguments, and which return a zero exit status on success and
non-zero exit status on failure. Confix recognizes test programs by
their filename prefix: you prefix the files containing the
@code{main()} routine with @file{_check}.

Once you have bootstrapped, configured and built your package, you run
the test suite by simply saying,

@example
$ pwd
/home/jfasch/tmp/build/wx-utils
$ make check
@end example

or, as we all know,

@example
@group
$ confix.py --packageroot=/home/jfasch/work/wx-utils \
            --make --targets=check
@end group
@end example

When the tests are finished, a statistic is given about the number of
tests passed and tests failed.

The @file{wx-utils} package contains a growing number of self-tests, they
are part of the @file{check} module@footnote{The module need not be
named @file{check}; you can give it any name you want.}.

@node Using Third Party Libraries, Restrictions Imposed on the Package Structure, Performing Automatic Tests, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Using Third Party Libraries

@cindex third party libraries
@cindex libraries, third party
@cindex external libraries
@cindex libraries, external
@cindex module description file
@cindex description file, module
@cindex repository, of module description files
So far we have only talked about instrumenting source code packages
with Confix. We have heard about the module description repository and
its role in building relationships between the packages that are
maintained with Confix. This is fine if all of the software in a
project is built using Confix. While this would be nice, it is not
quite realistic. For example, you would not easily convince the
maintainers of the GNU Readline library to convert their build to
Confix@footnote{I am quite confident that the feature set of Confix
had to be significantly enriched for this.}.

We heard that the module description repository contains information
about every module that was built (and installed) using Confix. This
information consists of things like

@itemize @bullet

@item
Provides and requires: these are the basic building blocks of module
dependencies. We have learned about them already.

@item
Checks: a collection of Autoconf checks that were performed when the
respective module was built. As we heard in @ref{Module Repository ---
Inter-Package Knowledge Transfer}, any module that uses another module
should perform the checks of that module, and this is what the module
description repository ensures.

@item
Instructions on how the module will participate in the build process
of a module that uses it. For example, if the module is a C/C++
library, then it will have to appear on the link line of the using
module at a certain position. Confix does this by calculating the
dependencies and sorting the modules accordingly, thereby getting a
correct link line.

@end itemize

Note that the module description does not contain build instructions
itself --- these are only of interest while building the modules of a
package. In the end, we do not need anything more than the three items
listed above to hook a third party library into one package's
dependency graph and build process.

@cindex provide
For Confix, an external module behaves exactly like a ``native''
module that has been built by Confix --- it's just that a bit of
handwork is necessary in that you'll have to write a few lines in the
module's @file{Makefile.py}. As opposed to a native module, you have
to at least manually @emph{provide} the module somehow. Else the
module will not get a chance to get into the dependency graph, and
thus it will not contribute to the link line or the include path of
other modules. Remember, a module provides itself through
@emph{provide} objects which you manually add to the module. The
remainder of this section consists of examples, accompanied with
explanations of what's going on.

@menu
* A Simple External Module::    
* A More Complicated External Module::  
@end menu

@node A Simple External Module, A More Complicated External Module, Using Third Party Libraries, Using Third Party Libraries
@comment  node-name,  next,  previous,  up
@subsection A Simple External Module

With stock Autoconf, you'll link in the Unix @emph{crypt} library like
so,

@example
AC_CHECK_LIB(crypt,crypt)
@end example

The M4 macro @code{AC_CHECK_LIB} will check if passing @code{-lcrypt}
on a program's link line will make the @code{crypt()} function
available, and add @code{-lcrypt} to the link line of the programs
that are built in the respective package. Furthermore, it will define
the C preprocessor macro @code{HAVE_LIBCRYPT} if @code{crypt()} is
available.

Without Confix it is the package maintainer's responsibility to place
@code{AC_CHECK_LIB} in @file{configure.in}. The Confix way is to
provide a ``library'' of external modules that provide appropriate
external module definitions. User code then refers to modules from
that library by --- either implicitly or explicitly ---
@emph{requiring} them.

The @file{wx-utils} package that accompanies Confix contains an external
module definition for the @code{crypt} library in the subdirectory
@file{ext-crypt}. A native module, in the @file{crypt} subdirectory of
that package contains a small C++ wrapper around the @code{crypt()}
function. The advantage of this constellation is that the native
module can serve as an automatic entry point into the external
library. The native module @emph{provides} a header file which is
included (@emph{required}) by other modules, with Confix taking care
of the dependencies automatically. The native module, in the
subdirectory @file{crypt}, manually requires the external module.

But first, let's see how the external module is defined in
@file{ext-crypt/Makefile.py}.

@cindex provide object, symbolic
@cindex symbolic provide object
@findex PROVIDE_SYMBOL
@example
@group
PROVIDE_SYMBOL(symbol='crypt')

CONFIGURE_IN(
    lines=['AC_CHECK_LIB(crypt,crypt)'],
    order=AC_LIBRARIES)
@end group
@end example

The first line adds a @emph{provide} object to the module. So far we
have only seen header files that act as provide objects. However the
@code{crypt} library has no header file of its own that declares the
@code{crypt()} function. Rather, @code{crypt()} is declared in the
standard C library header file @code{unistd.h} which declares zillions
of other symbols as well, and which is likely to be required by code
that does not want to make use of @code{crypt()}. So we have to use an
artificial provide object to announce our @file{ext-crypt} module. The
drawback to this is that we must also @emph{require} it artificially,
which is what we do in the native @code{crypt} module@footnote{If the
@code{crypt} library provided a header file of its own, say
@file{crypt.h}, we'd just have to add a provide object for a header
file --- @code{PROVIDE_H(filematch='crypt.h')} --- that matched the
corresponding @code{#include <crypt.h>} of any using modules
automatically.}.

@findex CONFIGURE_IN
The call to @code{CONFIGURE_IN()} adds our @code{AC_CHECK_LIB} macro
invocation to @file{configure.in}. See @ref{Interfaces for Coder and
Maintainer} for an explanation of the parameters.

@cindex require object, symbolic
@cindex symbolic require object
Now how's that module being used? The native module, @code{crypt},
that we've been talking about, has to reference it somehow. Normally
this is done implicitly by @code{#include}ing a header file. However,
we have no header file to include, so we have to manually require the
external module. This is easiest done in source file,
@file{crypt/crypt.cc}, using the @code{REQUIRE_SYMBOL()} from @ref{The
Buildable Interface}, like so,

@example
// CONFIX:REQUIRE_SYMBOL('crypt')
@end example

That symbolic @emph{require} object added to the @code{crypt} module
will match the symbolic @emph{provide} object we have used to announce
the external @file{ext-crypt} module, and thus introduce an edge in
the dependency graph. Every module that has a source file with the
line @code{#include <WX/Utils/crypt.h>} (this is what the native
@code{crypt} module provides) will link in the @code{crypt}
module. That module has a (symbolic) dependency on @code{ext-crypt},
which leads to @code{ext-crypt} (the Unix @code{crypt} library) to be
linked in as well.

But that's nothing special to external modules, that's how Confix
works. What's new here is that we've manually added provide ad require
objects, and that we have added Autoconf code.

In your C/C++ code you should react on the outcome of the check, of
course. This is nothing special to Confix, it applies to all coders
who manage their packages with Autoconf. In our case, the
@code{crypt()} function may or may not be
available. @code{AC_CHECK_LIB} defines the preprocessor macro
@code{HAVE_LIBCRYPT} if it is available, else the macro is
undefined. The code will look about like this (see
@file{crypt/crypt.cc} for the complete code),

@example
@group
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

std::string
Crypt::crypt(
   const std::string& key,
   const std::string& salt)
@{
#ifdef HAVE_LIBCRYPT
   return ::crypt(key.c_str(), salt.c_str());
#else
   THROW_ERROR_MSG(Error, "crypt(3) not available (HAVE_LIBCRYPT not defined)");
#endif
@}
@end group
@end example

@node A More Complicated External Module,  , A Simple External Module, Using Third Party Libraries
@comment  node-name,  next,  previous,  up
@subsection A More Complicated External Module

@cindex Python
Not all third party code is as easy to integrate as the @emph{crypt}
library. If you want to, for example, embed the Python interpreter,
you'd have to set the include and library path to somewhere inside the
Python installation directory. Furthermore, you'd have to find out
which libraries you have to link in order to get the necessary symbols
defined, and then add these libraries to your link lines, at the
correct position.

The @file{wx-utils} package contains a module, @file{ext-python}, which
has all necessary magic for you to use the Python interpreter
library. There is also a simple test program available,
@file{check/_check_python.cc}, which demonstrates --- quite
rudimentarily though --- usage of the Python interpreter.

Before we dissect @file{ext-python/Makefile.py}, let's do a little
background first. Confix's main task in generating build instructions
is to get link lines and include paths right. For this, it builds a
dependency graph of modules, and then topologically sorts the
graph. The outcome is a list of modules from which Confix computes
link lines and include paths.

To participate in the build of another module, a module must
contribute certain things such as the base names of the libraries it
offers, or the include path which has to be set. For example, the
@file{error} module of the @file{wx-utils} package offers the library
@file{libwx-utils_error.a} (or similar, the actual name depends on the
operating system, and Libtool usage). If an executable depends on that
module, then @code{-lwx-utils_error} --- the library's base name,
prepended with @code{-l} --- will have to appear on the linker
commandline that builds that executable, on the correct position.

@cindex checks, Autoconf
@cindex Autoconf checks
@cindex Autoconf, and third party code
Normally, when you build all of your source code with Confix, you
don't have to care about all this. Anyway, this is what's going on
under the hood, and you have to know this when you are going to write
Autoconf code to glue together third party software with your own
code. Basically, what has to be done is always the same,

@itemize @bullet

@item
Find out where the header files are that users of the third party
software include. You then pass it to the compiler. Take as a concrete
example our usage of the Python interpreter. If the Python
installation prefix was @file{/usr/local/Python-2.1.3}, then you'd
have to pass @code{-I/usr/local/Python-2.1.3/include} to the compiler.

@item
Find out what libraries you have to link executables with, and where
they are. With our Python example, the base names of the libraries are
@file{python2.1} (for Python itself), @file{pthread} (because the
interpreter happens to have been built with multithreading support
switched on), @file{dl} (the dynamic loader; Python uses to
@code{dlopen()} its C modules), and @file{util} (whatever that is, I
found it in @file{/usr/lib} on my Linux system). @file{libpython2.1.a}
is in @file{/usr/local/Python-2.1.3/lib/python2.1/config}, the rest is
in standard library directories which we don't have to care
about. With this, you'd have to pass
@code{-L/usr/local/Python-2.1.3/lib/python2.1/config -lpython2.1
-lpthread -ldl -lutil} to the linker.

@end itemize

This is what Autoconf is all about: finding out things. And this is
what most of the @file{ext-python/Makefile.py} is all about: define
Autoconf checks that have to be performed by every package that uses
@file{ext-python}.

At this point, you'll probably begin to suspect that you have to
become an Autoconf expert if you want to add third party software to
your projects. That's only halfway true. You sure have to have a basic
understanding of how Autoconf and Automake @emph{work}, and sure it's
helpful to be able to grasp how the macros that you use
work@footnote{Yes, I agree with you: M4 is a pain.}. Probably you will
get into the situation where you really have to write Autoconf code
yourself. But most of the time you will find yourself googling and
copying the pieces you found, just as I did with the Python stuff. But
anyway, I recommend reading the manuals and/or the
@uref{http://sources.redhat.com/autobook/,Autobook}; it's an
experience.

@findex EXTERNAL_LIBRARY2
Now that we found out the pieces which are necessary to use the Python
interpreter library, we have to hook these things into Confix. In our
case, the external module contributes link line fragments and include
directories to the rest of the world. For this, you use the
@code{EXTERNAL_LIBRARY2()} function of @ref{The Module Makefile.py
Interface}. But let's dive into @file{ext-python/Makefile.py}
now. We'll examine it piece by piece, commenting it as we go.

@example
@group
PROVIDE_H('Python.h')
@end group
@end example

@findex PROVIDE_H
Ah yes, I forgot to mention that we have to offer the module to
Confix's dependency resolution machinery somehow. Here we add a
provide object to our module, so that our module will be required by
every module where @code{#include <Python.h>} appears in one of its
source files.

Next, we define a few strings which contain Autoconf code, and which
we will add to the module later on. As you read this, you will
probably see the @code{r} in front of the string constants. This is
short for @emph{raw}, and it keeps Python@footnote{The Python
interpreter which is used to run Confix, not the one we are
integrating here :-)} from collapsing backslashes in the strings.

@example
@group
python_check = "AM_PATH_PYTHON"
@end group
@end example

@findex AM_PATH_PYTHON
@code{AM_PATH_PYTHON} is a macro that comes with Automake. It checks
for availability of the Python interpreter executable. If the
interpreter is found, certain shell variables will be set, such as
@code{$PYTHON} (the name of the Python executable),
@code{$PYTHON_VERSION}, and so on. The remainder of our checks will
use some of these variables.

@example
@group
header_check = r"""
AC_MSG_CHECKING(for headers required to compile python extensions)
dnl deduce PYTHON_INCLUDES
py_prefix=`$PYTHON -c "import sys; print sys.prefix"`
py_exec_prefix=`$PYTHON -c "import sys; print sys.exec_prefix"`
PYTHON_INCLUDES="-I$@{py_prefix@}/include/python$@{PYTHON_VERSION@}"
if test "$py_prefix" != "$py_exec_prefix"; then
  PYTHON_INCLUDES="$PYTHON_INCLUDES -I$@{py_exec_prefix@}/include/python$@{PYTHON_VERSION@}"
fi
AC_SUBST(PYTHON_INCLUDES)
dnl check if the headers exist:
save_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS $PYTHON_INCLUDES"
AC_TRY_CPP([#include <Python.h>],dnl
[AC_MSG_RESULT(found)],dnl
[AC_MSG_RESULT(not found)
PYTHON_INCLUDES=
])
CPPFLAGS="$save_CPPFLAGS"
"""
@end group
@end example

@findex AC_SUBST
The above code fragment looks for Python's include directory. If one
is found, it sets the @code{$PYTHON_INCLUDES} variable, which is also
@code{AC_SUBST}'ed. We will explain below what this means, and why it
is important to us.

@example
@group
lib_check = r"""
AC_MSG_CHECKING(for libpython$@{PYTHON_VERSION@}.a)

py_exec_prefix=`$PYTHON -c "import sys; print sys.exec_prefix"`

py_makefile="$@{py_exec_prefix@}/lib/python$@{PYTHON_VERSION@}/config/Makefile"
if test -f "$py_makefile"; then
dnl extra required libs
  py_localmodlibs=`sed -n -e 's/^LOCALMODLIBS=\(.*\)/\1/p' $py_makefile`
  py_basemodlibs=`sed -n -e 's/^BASEMODLIBS=\(.*\)/\1/p' $py_makefile`
  py_other_libs=`sed -n -e 's/^LIBS=\(.*\)/\1/p' $py_makefile`

dnl now the actual libpython
  if test -e "$@{py_exec_prefix@}/lib/python$@{PYTHON_VERSION@}/config/libpython$@{PYTHON_VERSION@}.a"; then
    PYTHON_LIBS="-L$@{py_exec_prefix@}/lib/python$@{PYTHON_VERSION@}/config -lpython$@{PYTHON_VERSION@} $py_localmodlibs $py_basemodlibs $py_other_libs"
    AC_MSG_RESULT(found)
  else
    AC_MSG_RESULT(not found)
  fi
else
  AC_MSG_RESULT(not found)
fi

AC_SUBST(PYTHON_LIBS)
"""
@end group
@end example

This does the same for the link line fragment we need. It sets and
@code{AC_SUBST}s the @code{$PYTHON_LIBS} shell variable. It is a bit
more complicated than the fragment that checks for the include
directory: it searches the @file{Makefile} in Python's @file{config}
directory for certain variables, and builds a list of libraries from
these. This is characteristic for this kind of checks --- the check
implementor knows about the structure of the installed package, and
writes shell code that examines that structure.

@example
@group
macro = r"""
if test -n "$PYTHON_LIBS" -a -n "$PYTHON_INCLUDES"; then
   AC_DEFINE(HAVE_PYTHON_LIB, 1, [We can use the Python library])
fi
"""
@end group
@end example

Here we see if anyone defined @code{$PYTHON_LIBS} and
@code{$PYTHON_INCLUDES}, and if so, define the C preprocessor macro
@code{HAVE_PYTHON_LIB}. This way user code can check at compile time
whether Python is available or not, and use it conditionally. See a
test program, @file{check/_check_python.cc}, for a simple yet stupid
and meaningless usage.

@findex CONFIGURE_IN
@cindex @file{configure.in}, ordering of code
Next, we call the @code{CONFIGURE_IN()} repeatedly to add these strings
to our enclosing module, as Autoconf fragments, in the appropriate
categories. This is, we add the check for the Python interpreter
executable in the category @code{AC_PROGRAMS}, the header check in
@code{AC_HEADERS}, the library check in @code{AC_LIBRARIES}, and the
macro definition @emph{after} @code{AC_HEADERS} and
@code{AC_LIBRARIES}. These constants are integer values which are far
enough apart so that @code{max(AC_LIBRARIES,AC_HEADERS)+1} won't overlap
into the next category. See @ref{Interfaces for Coder and Maintainer}
for more about the @code{CONFIGURE_IN()} function.

@example
@group
CONFIGURE_IN(
    lines=[python_check],
    order=AC_PROGRAMS)

CONFIGURE_IN(
    lines=[header_check],
    order=AC_HEADERS)

CONFIGURE_IN(
    lines=[lib_check],
    order=AC_LIBRARIES)

CONFIGURE_IN(
    lines=[macro],
    order=max(AC_LIBRARIES,AC_HEADERS)+1)
@end group
@end example

@findex EXTERNAL_LIBRARY2
Now we have made sure that any module that declares (through
@code{#include <Python.h>}) to use the Python interpreter library
applies these checks. The last thing we have to do is to contribute to
that module's build. For this, we use another function,
@code{EXTERNAL_LIBRARY2()} from @ref{The Module Makefile.py
Interface}.

@example
@group
EXTERNAL_LIBRARY2(
    inc='@@PYTHON_INCLUDES@@',
    lib='@@PYTHON_LIBS@@')
@end group
@end example

With this, we contribute include paths (the @code{inc} parameter) to
the compiler command line, and a link line fragment (the @code{lib}
parameter) to the linker command line. According to the module
dependency graph that Confix calculates, these will be placed at the
right position. 

What's interesting here is that we only contribute
@emph{placeholders}, @code{@@PYTHON_INCLUDES@@} and
@code{@@PYTHON_LIBS@@}. That's the Autoconf way. We have the configure
script determine things --- in our case, we apply shell and M4 code to
set or unset the shell variables @code{$PYTHON_INCLUDES} and
@code{$PYTHON_LIBS}. Then, we call the @code{AC_SUBST} macro with
these variables. This macro takes care to substitute all occurences of
the equally named placeholders with the values of these variables ---
@emph{at @code{configure} time}.

In the end, what Confix does is to generate a @file{Makefile.am} only
with these placeholders at the compiler and linker command
lines. Additionally, checks are added that take care that the
placeholders will be filled in when the user calls
@code{configure}. That's exactly what an Automake or Autoconf user
would do: write the checks into the @file{configure.in} in the package
root directory, and put the placeholders in the various locations
where they are needed. It's just that Confix gives you the possibility
to have the placeholders and the checks together in one place, without
having to keep them consistent among many files, and that Confix takes
care of their correct placement.

@node Restrictions Imposed on the Package Structure, Using GNU Libtool, Using Third Party Libraries, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Restrictions Imposed on the Package Structure

@cindex structure, of the package
@cindex package structure, restriction
@cindex restriction, package structure
@cindex package depth
@cindex depth first traversal, build order
@cindex build order, and depth first traversal
As we saw in previous sections, with stock Autotools the maintainer
has to specify the build order in his package @emph{by hand}. For a
package tree with multiple levels of depth, like this one,

@example
@group
packageroot/
|-- mod1
|   |-- mod1.1
|   `-- mod1.2
`-- mod2
    |-- mod2.1
    `-- mod2.2
@end group
@end example

the maintainer may want specify a build order @file{mod1.1, mod1.2,
mod2.1, mod2.2} in the @file{Makefile.am} files as follows,

@itemize @bullet

@item
In the toplevel @file{Makefile.am}: @code{SUBDIRS = mod1 mod2}

@item
In @file{mod1/Makefile.am}: @code{SUBDIRS = mod1.1 mod1.2}

@item
In @file{mod2/Makefile.am}: @code{SUBDIRS = mod2.1 mod2.2}

@end itemize

In other words, the maintainer explicitly specifies a @emph{depth
first traversal} through the package tree, thereby explicitly
specifying a @emph{build order}.

As Confix automatically determines the build order, the maintainer
need not (must not, and cannot) influence the build order except
through his placement of @emph{provides} and @emph{requires}. With the
right (wrong) placement of @emph{provides} and @emph{requires} it
could easily happen that Confix calculates a build order about as
@file{mod1.1, mod2.1, mod1.2, mod2.2} which is clearly no DFS
traversal. Confix would then generate a toplevel @file{Makefile.am}
which contains

@example
SUBDIRS = mod1/mod1.1 mod2/mod2.1 mod1/mod1.2 mod2/mod2.2
@end example

@cindex @command{make dist}
This is fine in principle. There are probably no problems while
building the package. It's just that @command{make dist} and friends
(see @ref{Distributing the Package}) will not work correctly when the
toplevel @file{Makefile.am} spans more than one level of the package
hierarchy. Moreover, the Automake 1.7 documentation states that,

``The directories mentioned in @code{SUBDIRS} must be direct children
of the current directory.  For instance, you cannot put
@samp{src/subdir} into @code{SUBDIRS}.  Instead you should put
@code{SUBDIRS = subdir} into @file{src/Makefile.am}.  Automake can be
used to construct packages of arbitrary depth this way.''

So, now's the time to put another burden on the Confix user:
@strong{Packages must have flat hierarchies of only one level deep.}
In other words, the above package must be restructured to

@example
@group
packageroot/
|-- mod1.1
|-- mod1.2
|-- mod2.1
`-- mod2.2
@end group
@end example

@node Using GNU Libtool, Summary of Rules and Restrictions, Restrictions Imposed on the Package Structure, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Using GNU Libtool

@cindex Libtool
@cindex shared library, and Libtool
Confix provides optional support for GNU Libtool. That is, the
maintainer has to decide whether he wants to use Libtool to build the
package's libraries or not. See @ref{Options and Parameters} for the
@option{--use-libtool} option, and @ref{The Configuration File} for
the corresponding variable in the configuration file.

GNU Libtool is used to build shared libraries in a portable manner. It
introduces an abstraction layer, the @emph{libtool archive}, to hide
the differences between shared and static libraries. When it cannot
build shared libraries on a certain operating system or architecture,
it builds static libraries only, and everything continues to
work@footnote{I have to admit that I don't know how and why Libtool
works, but I gladly accept it @emph{does} work.}. It also adds a few
commandline options to the @code{configure} script; for example, you
may specify @option{--disable-shared} suppress building of shared
libraries and to only build static libraries. See
@uref{http://www.gnu.org/software/libtool/manual.html, the Libtool
manual} if you want to know more. The remainder of this section is
about Libtool usage with Confix.

@cindex C++, and Libtool
Historically, shared library implementations on the various operating
systems have been working with C for a long time. A major challenge is
building shared libraries (let alone running programs with them) with
C++. Several features of C++ do not work right out of the box with
shared libraries. For example, global initializers must be run when
the library is loaded - a task which has been mastered by Libtool in
the meantime@footnote{In the past, they used to call the linker,
@command{ld}, directly to produce the shared library. Of course the
linker has no idea of C++, so initializers weren't generated at
all. Meanwhile the C++ linker frontend is called, so these
initializers are generated (and called by the dynamic loader)
properly.}.

In short, Libtool is now (as of version 1.5) in the shape to generate
C++ shared libraries correctly. As long as certain preconditions are
met. One precondition is that all code is compiled with the same
compiler@footnote{This restriction is not specific to shared
libraries, but applies to linking C++ code in general.}.

Another, more serious, restriction is exception handling. When an
exception is thrown by a function, all stack frames have to be unwound
(destructors have to be called) up to the point where the exception is
caught. This means that the C++ compiler has to generate code for
every stack frame that registers the frame with a common --- global
--- data structure, a list of active stack frames. The exception
handling code, also generated by the compiler, then traverses that
list and unwinds the stack.

@cindex C++, GCC, and Libtool
The problem here is that certain compilers have problems with making
that global list truly global. (I'm going to outline the problem for
GCC under Linux, as I don't yet have experiences with other
combinations. As I gain experience, I'll write it down here. I'm also
glad to receive contributions.)

When you have several shared libraries that work together inside a
program, then only one of them should own the stack frame list. Else,
when the libraries are loaded, confusion occurs if more or all of the
libraries have that symbol, and the results are funny when an
exception is actually thrown. Usually, the symptom is that the
exception cannot cross the boundary between two shared
libraries@footnote{I suspect this is due to the fact that every
library uses its own frame list internally. This way, the effective
stack is not reflected by any frame list in the program's address
space.}. The solution is to put the frame list in a single shared
library, and to have the others only depend on that library.

GCC has always put it support routines and data structures in a single
support library. Unfortunately, before version 3 of GCC, this library
was a static library, @file{libgcc.a}. Even more unfortunately, GCC
built shared libraries in a way that attached the code in
@file{libgcc.a} to it. The outcome was the scenario explained above:
multiple overriding definitions of the frame list.

GCC 3 does the right thing --- @file{libgcc} is a shared library. This
means that exception handling can work with GCC 3, and it really does
work. Unfortunately, most current Linux distributions come with a GCC
that is far from version 3@footnote{I fearfully remember Redhat's GCC
2.96.} (today is September 19, 2003), so you probably have to compile
your own compiler. How to do this is out of the scope of Confix;
suffice it to give a few hints and warns.

@itemize @bullet

@item
Do not install your custom compiler in a place where it could conflict
with the compiler that comes with the system. Certain activities
require the system's compiler to work as expected by the distributor;
kernel compilation is an example.

Pass the @option{--prefix} option to GCC's configure script to install
your own GCC in a different location.

@item
You need to tell the dynamic loader where GCC's shared libraries can
be found. Under Linux, you do this by adding GCC's library directory,
@file{@emph{prefix}/lib}, to @file{/etc/ld.so.conf}, and then calling
@command{ldconfig}.

@end itemize

Confix does not do really much to build shared libraries. All it does
is try to generate correct input for Automake and Libtool, and we even
managed to build shared libraries that can be @code{dlopen()}'ed
without problems, at least under Linux. However, despite its
untestedness on other systems, this is how it's supposed to work, and
everything else is either a bug or has to be documented
explicitly. Dear reader, please be kind and give input.

@menu
* Objections Against Shared Libraries ::  
@end menu

@node Objections Against Shared Libraries ,  , Using GNU Libtool, Using GNU Libtool
@comment  node-name,  next,  previous,  up
@subsection Objections Against Shared Libraries

Shared libraries are a great feature of modern operating
systems@footnote{In fact, shared library imlementations are not
generally implemented by the kernel. Rather, a user space program,
called the @emph{loader}, is responsible for setting up the process's
memory layout, and to load all involved shared libraries. In doing so,
it uses advanced kernel features such as memory mapped files.}. They
dramatically reduce the sizes of executables because common code is
kept externally. When two or more executables use the same shared
library, only one instance of the code has to be physically present in
memory.

There is a big disadvantage however. Your executables are not self
contained anymore, but rather depend on external factors. Shared
libraries themselves are only the tip of the iceberg. Another
important factor is that there can be more than one version of a
shared library around. Changing the interface of a shared library
without changing its version will wreak havoc on all executables that
are linked against that library. Despite these difficulties, lots of
projects have managed to get it right --- after all, it's mainly a
matter of discipline, and programmers tend to be disciplined if not
paranoid.

C++ is the final tidbit in this area. As described above, C++
compilers usually come with one or more shared libraries which contain
necessary data structures to ensure that certain C++ features work
correctly in the presence of shared linraries. While this is
desirable, it introduces one more dependency. You have to ensure that
the version of the installed compiler matches the version of the
compiler that you built your shared libraries with.

@node Summary of Rules and Restrictions,  , Using GNU Libtool, The Coders Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Summary of Rules and Restrictions

This chapter explained how Confix guesses build instructions from the
package's content, and what restrictions it imposes on the package
maintainer. The explanations have been a bit technical and lengthy,
however, so here's a short summary.

@itemize @bullet

@item
In a module's directory, buildable files are determined by their
extensions. @xref{What Will Be Built}.

@item
Header files which begin with an underline are only visible to modules
inside the same package, during the build process. They are not
installed during @command{make install}. All other header files are
installed. @xref{What Goes Public}.

@item
C++ header files which have a namespace declared, say @file{A/B}, are
installed in a directory
@file{$(prefix)/include/A/B/headerfile.h}. They should be included by
foreign code like @code{#include
<A/B/headerfile.h>}. @xref{Namespaces}.

@strong{Restrictions:} Within a module, you can only have either no
namespace, or you can have only one namespace. In other words, you
cannot have

@itemize @bullet

@item
Files with no namespace and files with a namespace besides each other
in a module

@item
Files with different namespaces besides each other in a module

@end itemize

@item
As for module dependencies: If module A depends on module B, then
module B @emph{must not use any bit} of module A. @xref{Build Order ---
How Things Can Easily Go Wrong}.

@item
You can add Autoconf checks in the source code, right where you use
the results of that check. @xref{Explicitly Adding Checks}.

@item
Your package's directory hierarchy must be flat --- this is, every
directory which contains a module must be a direct descendant of the
package root. @xref{Restrictions Imposed on the Package Structure}.

@end itemize

@node The Users Role in the Build Process, Options and Parameters, The Coders Role in the Build Process, Top
@comment  node-name,  next,  previous,  up
@chapter The User's Role in the Build Process

@menu
* Optionally Building and Using Modules::  
@end menu

@node Optionally Building and Using Modules,  , The Users Role in the Build Process, The Users Role in the Build Process
@comment  node-name,  next,  previous,  up
@section Optionally Building and Using Modules

Blah --enable-..., --with-... (local modules and installed modules,
resp.)

Blah feature macros; references to the interface documentation
appendixes.

Examples using the @file{wx-utils} package, plus one package that uses the @file{wx-utils}
package. configure --help output.

@node Options and Parameters, Interfaces for Coder and Maintainer, The Users Role in the Build Process, Top
@comment  node-name,  next,  previous,  up
@appendix Options and Parameters

@cindex commandline arguments
@cindex action names
The Confix commandline is composed of @emph{action names} and
@emph{parameters}. Action names are used to tell Confix what to do;
for example, the key feature of Confix - instrumenting a source tree
by creating @file{configure.in} and @file{Makefile.am} - is specified
by the commandline argument @option{--output}.

@cindex action, dependency
@cindex dependent actions
@cindex @option{--output}
@cindex @option{--bootstrap}
Some actions implicitly invoke other actions. For example,
@option{--bootstrap} invokes the @var{output} action although
@option{--output} was not specified on the commandline. If the user does
specify these actions on the commandline, the ordering does not
matter. If you say, for example, @code{confix.py --bootstrap --output},
this does not mean that the @var{output} action is performed twice - the
first time implicitly through @option{--bootstrap}, and the second time
explicitly through @option{--output}. Rather, the explicit
@option{--output} takes no effect because it has already been performed.

Independent actions are performed in the order they are specified on
the commandline.

Some of the parameters are configurable in the configuration
file. This saves you from typing. See @ref{The Configuration File} for
more information.

@menu
* Actions::                     
* Parameters::                  
@end menu

@node Actions, Parameters, Options and Parameters, Options and Parameters
@comment  node-name,  next,  previous,  up
@appendixsec Actions

@itemize @bullet

@item @option{--help}
@cindex @option{--help}

Writes to stderr a more or less detailed list of available commandline
options. The list is less detailed than the list you are currently
starting to read, but should suffice as a quick reference.

@item @option{--resolve}
@cindex @option{--resolve}

@cindex provide
@cindex require
Examine the package tree. Scan for files that have to be built and
installed. Determine @emph{provides} and @emph{requires}. Read the
module descriptions from the module description respository. Try to
resolve the package's @emph{requires} against the @emph{provides}
available from either

@itemize @bullet

@item
The package's other modules (the subdirectories of the package root
which is just being scanned). Dependencies among the package's modules
influence their build order, by the way.

@end itemize

or from

@itemize @bullet

@item
@cindex repository, of module descriptions
@cindex module description
The modules whose descriptions have been read from the module
description respository.

@end itemize


Parameters:

@itemize @minus

@item 
@cindex @option{--packageroot}
@var{packageroot}

@item
@cindex @option{--repository}
@var{repository}: directory where the module descriptions are installed.

@end itemize

Examples:

@itemize

@item
From anywhere you want (@option{--packageroot} specifies the package)

@example
$ confix.py --resolve --packageroot=$HOME/work/wx-utils
--repo=$HOME/wxpackages/repo
@end example

(@option{--repo} specifies where to get module descriptions from)

@item
Or equivalently, if the current working directory is
@file{$HOME/work/wx-utils},

@example
$ confix.py --resolve --repo=$HOME/wxpackages/repo
@end example

@item
Or even more equivalently, because the default repository is
@code{$(prefix)/repo},

@example
$ confix.py --resolve --prefix=$HOME/wxpackages
@end example

@end itemize


@item @option{--output}
@cindex @option{--output}

Instrument a package. This involves scanning the package tree for files
that have to be built and installed, generating @file{configure.in} and
@file{Makefile.am} in the package root, and a @file{Makefile.am} in
every module subdirectory of the package root which contains a
@file{Makefile.am}.

Depends on: 

@itemize @minus

@item
@var{resolve}

@end itemize

Parameters:

@itemize @minus

@item
@var{packageroot}, through the @var{resolve} action.

@item
@var{repository}, likewise.

@item
@var{prefix}, likewise.

@end itemize

Example:

@itemize
@item
In the package root,
@example
$ confix.py --output --prefix=$HOME/wxpackages
@end example
@end itemize


@item @option{--bootstrap}
@cindex @option{--bootstrap}

Bootstraps a package. In Autoconf/Automake terminology, this is the
process of converting the (handwritten, if not generated by Confix)
@file{configure.in} and @file{Makefile.am} to @code{configure} and
@file{Makefile.in}, respectively. In Confix terminology, bootstrapping
means creating @file{configure.in} and @file{Makefile.am} first (which
is done implicitly by the @var{output} action), and then doing the
autotools bootstrap.

Depends on:

@itemize @minus

@item
@var{output}

@item
@var{resolve} (recursively through output)

@end itemize

Parameters:

@itemize @minus

@item
None of its own, only the parameters pulled in by actions which
@var{bootstrap} depends upon.

@end itemize

Examples:

@itemize

@item
In the package root,
@example
$ confix.py --bootstrap --prefix=$HOME/wxpackages
@end example

@item
Or, from elsewhere
@example
$ confix.py --bootstrap --packageroot=$HOME/work/wx-utils \
            --prefix=$HOME/wxpackages
@end example

@end itemize


@item @option{--configure}
@cindex @option{--configure}

Call the package's @command{configure} script in the package's
compilation directory. One might expect that this action implictly
invokes the @var{bootstrap} action. This is not the case however,
because it makes sense to configure a package several times. For
example, the compilation directory might have been removed brutally by
an angry user who ran out of disk space. It makes no sense to
re-bootstrap the source then. Moreover, an implicit bootstrap would
violate the separation between maintainer and user as
@option{--configure} is a @emph{user} option. Put shortly,
@var{configure} is a standalone action.

@emph{Note} that the environment variables visible to
@command{configure} can considerably influence its behavior. For this
reason a clean environment is passed to the script. Environment
variables can be set via the configuration file on a per-profile basis.

Parameters:

@itemize @minus

@item
@var{packageroot}. We need the package root in order to compute the path
to the @command{configure} command.

@item
@var{buildroot}, or

@item
@var{builddir}

@end itemize


Examples:

@itemize

@item
Configure the package located in @file{$HOME/work/wx-utils} in the
directory @file{$HOME/build/wx-utils}.

@example
$ confix.py --configure --packageroot=$HOME/work/wx-utils
--builddir=$HOME/build/wx-utils
@end example


@item
Same as above. The @var{builddir} parameter is computed from
@var{packageroot} and @var{buildroot}.

@example
$ confix.py --configure --packageroot=$HOME/work/wx-utils
--buildroot=$HOME/build
@end example

@item
The same as above, provided that, in your configuration file (see
below), in the '@code{default}' profile, you have specified that the
@var{buildroot} is @file{$HOME/build}.

@example
$ confix.py --configure --packageroot=$HOME/work/wx-utils
@end example

@end itemize


@item @option{--make}
@cindex @option{--make}

Call @command{make} in the package's compilation directory. The
treatment of @var{buildroot}, environment variables, and so on, is
similar to that of the @var{configure} action. Note that it is
irrelevant for @command{make} where the @var{packageroot} is.

Parameters:

@itemize @minus

@item
@var{targets}

@end itemize

Examples:

@itemize

@item
In the package root,
@example
$ confix.py --make --targets='all install' \
    --builddir=$HOME/build/wx-utils
@end example
(or any of the variations of @var{builddir} presented above).

@item
@var{bootstrap}, @var{configure}, and @var{make} are independent
actions, although you can meaningfully combine them on the commandline
to do a whole lot of work in one swoop,
@example
$ confix.py --bootstrap --configure --make
--packageroot=$HOME/work/wx-utils --builddir=$HOME/build/wx-utils
@end example
@emph{Note} that the order in which you specify the actions is
important, as it makes no sense to configure a package unless it has
been bootstrapped before. Likewise, a premature @command{make}
invokation will lead to error messages in one way or the other.

@end itemize

@end itemize


@node Parameters,  , Actions, Options and Parameters
@comment  node-name,  next,  previous,  up
@appendixsec Parameters
@cindex parameters

This section lists the parameters which are relevant to most of the
action arguments described above. Although there are reasonable
default values for most of the parameters, it can be tedious if you
have to specify them on the commandline again and again. An easier way
for this is to write a configuration file @file{.confix} in your home
directory where you can specify most of these parameters. The relevant
parameters to control the configuration file and how parameters are
selected from it are @option{--configfile} and @option{--profile}
which are described below. See @ref{The Configuration File} for the
syntax of this file. Suffice it for now to state that parameters
specified on the commandline have precedence over the configuration
file.

@itemize @bullet

@item @option{--advanced}
@cindex @option{--advanced}

Use Confix in advanced mode, by trying to perform reasonable actions
in some cases instead of displaying errors and stopping. Specifically,
this causes build directories (see the @option{--builddir} option) to
be created automatically if they do not exist.

In the future this behavior might be expanded to included various
automatic repository actions, for example, automatic selection of a
package from multiple conflicting repositories.

The default is to disable advanced behavior.

@item @option{--configfile}
@cindex @option{--configfile}

The name of extra configuration files to read after loading the
@file{$HOME/.confix} personal configuration file.

The default is to load no extra configuration files.

@item @option{--profile}
@cindex @option{--profile}

The name of the configuration profile to be selected from the
configuration file. (See below for a description of what a profile is
and how to use it.)

The default profile name is '@code{profile}'.

@item @option{--prefix}
@cindex @option{--prefix}

The prefix (a directory) where the package will be installed to, once it
is built. Also, this serves as the default prefix for the
@option{--repository} parameter (see there).

No default available.

@item @option{--packageroot}
@cindex @option{--packageroot}

The name of the directory where the package's source tree begins.

The default is the current working directory.

@item @option{--packagename}
@cindex @option{--packagename}
@cindex package name

The package name. For example, library names are generated automatically
from the package name and the module name, as with
@file{libwx-utils_error.a}, where @code{wx-utils} is the package name and
@code{error} is the module name within the package.

This option takes precedence over the @code{NAME()} package property
written in the package interface file (see @ref{The Toplevel
Makefile.py Interface}).

@item @option{--packageversion}
@cindex @option{--packageversion}

The package version. This really only affects the name of the
resulting distribution tarball.

The default is 0.0.0.

@item @option{--repository}
@cindex @option{--repository}

The directory where module descriptions are installed. Remember, module
descriptions are files where an installed module's properties are
recorded. These are the things a module @emph{provides}, such as include
files @emph{required} by other modules, and the @emph{content} of a
module, such as the path to be passed to the compiler to find the
module's include files, the libraries to link, and so on.

The default repository is @file{$(prefix)/repo}.

@item @option{--buildroot}
@cindex @option{--buildroot}

The directory where you usually compile your packages in. Every
subdirectory of it corresponds to a compilation tree of one particular
package.

No default available.

@item @option{--builddir}
@cindex @option{--builddir}

The compilation directory of the current package. This is made the
current working directory during the @var{configure} and @var{make}
actions.

The default compilation directory is @file{<buildroot>/<basename of
packageroot>}.

@item @option{--use-libtool}
@cindex Libtool
@cindex shared libraries, and Libtool
@cindex libraries, shared, Libtool

If you specify this flag, output will be generated that makes use of
Libtool. This means that building libraries is done by Libtool, and,
depending on the support of Libtool for the target architecture,
either shared or static libraries, or both, will be built. By default
this is switched off, and output is generated that builds plain
archives, without Libtool.

@item @option{--targets}
@cindex @option{--targets}

A string which contains whitespace-separated targets suitable for the
@var{make} action.

@item @option{--trace}
@cindex @option{--trace}

For debugging. You can specify the following trace levels, which you
separate with a comma. The output goes to standard error.

@itemize @minus

@item @code{require}

During the package scan process, output what the modules @emph{require}.

@item @code{provide}

During the package scan process, output what the modules @emph{provide}.

@item @code{resolve}

During the package resolving process (remember, this is where module
dependencies are calculated), output which @emph{provide}s satisfy which
@emph{require}s.

@item @code{repo}

Output information about what is being discovered in the module
description repository.

@item @code{check}

Output which module demands which @command{autoconf} checks.

@end itemize

Example:

@command{confix.py --output --trace=provide,require}

@item @option{--debug}
@cindex @option{--debug}

Enable overall debugging messages. 

Example:

@command{confix.py --output --debug=1}

@end itemize


@node Interfaces for Coder and Maintainer, The Configuration File, Options and Parameters, Top
@comment  node-name,  next,  previous,  up
@appendix Interfaces for Coder and Maintainer

Before Confix generates Automake and Autoconf input files, it scans
the package for information about what to generate. On one hand, and
that is where most of that information ideally comes from, it reads
the source code of the package and makes wild guesses on what to do
with that source code. On the other hand there is the possibility for
the package maintainer to write explicit instructions for
Confix. There are many reasons why one might want to do that, one
being that Confix simply cannot guess everything only from the source
code and needs help from the maintainer.

This chapter explains the various places where one can specify build
instructions: the toplevel (package) @file{Makefile.py}, a module's
@file{Makefile.py}, and the buildables themselves (one can write
explicit build instructions in various kinds of source files --- but
read on). All of the interfaces have a few things in common. First,
since Confix is written in Python, and Python provides very elegant ways
of embedding user code, the interfaces we will be talking about are also
in Python. Generally speaking, you can write arbitrary Python code and
use the Confix interface functions from it.

@cindex calling convention, of interface functions
Second, the parameter sets of the interface functions are subject to
extension. Although we will try to maintain backwards compatibility as
far as possible, it is quite likely that new parameters are added
under the hood. A consequence of this is that @emph{you should not use
positional arguments, but rather use keyword arguments
instead}@footnote{We do not document the order of the parameters, but
only their names; so there is no way to call the functions without
using keyword arguments anyway.}.

Third, the sets of interface functions which are available in the
package, the module, and the buildable are not necessarily disjoint. For
example, all of them allow the maintainer to add code to the
@code{configure.in} and @code{acinclude.m4} files using the
@code{CONFIGURE_IN()} and @code{ACINCLUDE_M4()} interface functions,
respectively. For the sake of readablilty, we chose to explain each of
these function in every section, rather than referring to one common
place.

@menu
* The Module Makefile.py Interface::  
* The Buildable Interface::     
* The Toplevel Makefile.py Interface::  
@end menu

@c WE DUPLICATE TEXT IN THE SUBSEQUENT SECTIONS ABOUT THE PACKAGE-, MODULE,
@c AND BUILDABLE INTERFACES. WE DON'T DO SO BRUTALLY HOWEVER, BUT RATHER
@c USE MACROS FOR IT. TAKE CARE TO CROSS CHECK THE THREE SECTIONS IF YOU
@c CHANGE THE MACRO TEXT.
@c 
@c BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS
@c BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS
@c BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS, BEGIN MACROS

@macro CONFIGUREINcommon{iface}

Perhaps the most central part in maintaining a package is crafting M4
and Bourne shell code in @file{configure.in}. Confix tries to relieve
you as much as possible from this job. However, at the point where you
are using third party code, you have to dive into it (there are other
situations, but this is the most common). See @ref{Using Third Party
Libraries} for usage examples.

\iface\ offers an interface function, @code{CONFIGURE_IN()}, which you
can use to hook arbitrary code fragments into the package's
@file{configure.in} file. Its parameters are explained below.

@end macro

@macro ACINCLUDEcommon{iface}

The file @file{acinclude.m4} can be thought of as a kind of "library"
where one can place macro definitions that are used from code in
@file{configure.in}. Just like the @code{CONFIGUE_IN()} interface
function adds code to the @file{configure.in} file,
@code{ACINCLUDE_M4()} can be used to add code to @file{acinclude.m4}.

@end macro

@macro CONFIGUREINlines{}
A list of strings, the lines which will appear in @file{configure.in}.
@end macro

@macro ACINCLUDElines{}
A list of strings, the lines which will appear in @file{acinclude.m4}.
@end macro

@macro CONFIGUREINorder{}

Depending on what @code{lines} contains, it is important that the lines
do not interfere with other invocations of @code{CONFIGURE_IN()}. For
example, it might be important to check for the presence of a particular
program @emph{before} another check applies that program. That's what
the @code{order} parameter is for. There are predefined constants for
@code{order} values which you should use for @code{CONFIGURE_IN()}, and
which are named according to the ``Ordering Tests'' section in the
@uref{http://sources.redhat.com/autobook/,Autotools book}. Following is
a description of the meaning of each value, taken literally from the
book.

@cindex @file{configure.in}, ordering of code

@enumerate


@item
@code{AC_BOILERPLATE}. This section should include standard boilerplate
code, such as the call to @code{AC_INIT} (which must be first),
@code{AM_INIT_AUTOMAKE}, @code{AC_CONFIG_HEADER}, and perhaps
@code{AC_REVISION}@footnote{Confix inserts these by itself, so you don't
have to care of them. I just copied the text from the book for
correctness.}.

@item
@code{AC_OPTIONS}. The next section should include macros which add
command-line options to configure, such as @code{AC_ARG_ENABLE}. It is
typical to put support code for the option in this section as well, if
it is short enough, like this example from libgcj:

@example
@group
AC_ARG_ENABLE(getenv-properties,
[  --disable-getenv-properties
                          don't set system properties from GCJ_PROPERTIES])

dnl Whether GCJ_PROPERTIES is used depends on the target.
if test -n $enable_getenv_properties; then
   enable_getenv_properties=$@{enable_getenv_properties_default-yes@}
fi
if test $enable_getenv_properties = no; then
   AC_DEFINE(DISABLE_GETENV_PROPERTIES)
fi
@end group
@end example

@item
@code{AC_PROGRAMS}. Next it is traditional to check for programs that
are either needed by the configure process, the build process, or by
one of the programs being built. This usually involves calls to macros
like @code{AC_CHECK_PROG} and @code{AC_PATH_TOOL}.

@item
@code{AC_LIBRARIES}. Checks for libraries come before checks for other
objects visible to C (or C++, or anything else). This is necessary
because some other checks work by trying to link or run a program; by
checking for libraries first you ensure that the resulting programs
can be linked.

@item
@code{AC_HEADERS}. Next come checks for existence of headers.

@item
@code{AC_TYPEDEFS_AND_STRUCTURES}. We do checks for typedefs after
checking for headers for the simple reason that typedefs appear in
headers, and we need to know which headers we can use before we look
inside them.

@item
@code{AC_FUNCTIONS}. Finally we check for functions. These come last
because functions have dependencies on the preceding items: when
searching for functions, libraries are needed in order to correctly
link, headers are needed in order to find prototypes (this is
especially important for C++, which has stricter prototyping rules
than C), and typedefs are needed for those functions which use or
return types which are not built in.

@item
@code{AC_OUTPUT}. This is done by invoking AC_OUTPUT@footnote{Again,
@code{AC_OUTPUT} invocation is Confix's responsibility, though you are
free to call AC_OUTPUT by yourself as well.}.

@end enumerate

@end macro

@macro ACINCLUDEid{}

String; the unique identifier of the code fragment. When Confix
instruments a package, each module contributes its @file{acinclude.m4}
fragments to every module that uses it. At the end of the process, each
module contributes its fragments to the enclosing package which finally
writes @file{acinclude.m4}. This way it is possible that the fragments
reach the package multiple times. The package sorts these out based on
their unique identifiers.

@end macro

@c END MACRO, END MACRO, END MACRO, END MACRO, END MACRO, END MACRO
@c END MACRO, END MACRO, END MACRO, END MACRO, END MACRO, END MACRO
@c END MACRO, END MACRO, END MACRO, END MACRO, END MACRO, END MACRO

@node The Module Makefile.py Interface, The Buildable Interface, Interfaces for Coder and Maintainer, Interfaces for Coder and Maintainer
@comment  node-name,  next,  previous,  up
@appendixsec The Module @file{Makefile.py} Interface

@cindex interface functions, module
@cindex module, interface functions
When Confix sees a @file{Makefile.py} file in a package's subdirectory,
it concludes that there's something to build in that directory. It then
examines the directory's content, and generates build instructions for
the files it can handle. Normally, the @file{Makefile.py} can be left
empty, it just needs to be there as a marker for Confix. However,
sometimes you may want to provide some explicit build instructions for a
module. For this, Confix provides a couple of functions that you may
invoke in @file{Makefile.py}.

@itemize @bullet

@item
@findex CONFIGURE_IN, module interface
@findex CONFIGURE_IN
@code{@strong{CONFIGURE_IN()}}. @CONFIGUREINcommon{The module interface}

@itemize @bullet

@item
@code{lines}. @CONFIGUREINlines

@item
@code{order}.

@CONFIGUREINorder

@item
@code{propagate_only}. Boolean. By default, a code fragment added to the
module by @code{CONFIGURE_IN()} is added to the enclosing package's
@file{configure.in} file. This is done regardless if the module is used
by another module in the same package or not, and this has the effect
that @file{configure.in} fragments are executed by the @code{configure}
script even if nobody in the package uses it. Sometimes one wants to
prepare a package whose sole purpose is to contain definitions of third
party code that can be used by other packages. As that package contains
only third party code definitions and makes no use of them by itself,
one does not want that package's @code{configure} script to perform all
these checks. The checks should only be performed by the
@code{configure} scripts of those packages that pull them in@footnote{If
you don't understand what I'm talking about here drop me a note, or
better yet, file a bug report. I won't be surprised.}.

Anyway, if you want to suppress execution of the code by the enclosing
package's @code{configure} script, pass @code{1} as the value of this
parameter. It will then only be propagated to outside code that declares
to be using it. The parameter will be ignored if the module happens to
be used in the enclosing package, however, and the check will be
performed anyway.

@end itemize

@item
@findex ACINCLUDE_M4, module interface
@findex ACINCLUDE_M4
@code{@strong{ACINCLUDE_M4()}}. @ACINCLUDEcommon{}

@itemize @bullet

@item
@code{lines}. @ACINCLUDElines

@item
@code{id}. @ACINCLUDEid

@item
@code{propagate_only}. Boolean. Analogous to @code{propagate_only} of
the @code{CONFIGURE_IN()} function. See there.
@end itemize

@item
@findex PROVIDE_H
@code{@strong{PROVIDE_H()}}. Add a provide object of type ``C/C++ header
file''.

Parameters:

@itemize @bullet

@item
@code{filematch}. String; required. A shell-like match expression
which determines which corresponding require objects are matched by
the provide object. The match is evaluated by the Python
@code{fnmatch.fnmatchcase()} function.

@item
@code{provide_mode}. String; values are either 'public' or 'package'.

@end itemize

@item
@cindex provide object, symbolic
@cindex symbolic provide object
@findex PROVIDE_SYMBOL
@code{@strong{PROVIDE_SYMBOL()}}. Add a provide object of type
``symbolic''. This is not much different from @code{PROVIDE_H()}; it
can resolve a require object of type ``symbolic'' which can be added
using @code{REQUIRE_SYMBOL()}. The only difference is that the symbol
name is a plain string rather than a shell glob@footnote{Symbolic
provides were introduced after I hacked dependencies between external
modules. At that time I used ``artificial'' header files, added with
@code{PROVIDE_H()} and @code{REQUIRE_H()}, as provides and requires,
to get the link order of the external libraries right. I thought that
symbolic counterparts were more appropriate for this.}.

Parameters:

@itemize @bullet

@item
@code{symbol}. String; required. The name of the symbol that is
provided by the module.

@item
@code{provide_mode}. String; values are either 'public' or
'package'.

@end itemize

An example usage of @code{PROVIDE_SYMBOL()} and its counterpart
@code{REQUIRE_SYMBOL()} (described below) can be found in the
@file{wx-utils} package. There, module @file{crypt} depends on module
@file{ext-crypt} because both of them contain a matching pair of
require and provide objects. @file{crypt/crypt.cc} adds a symbolic
require object to its containing module by saying
@code{REQUIRE_SYMBOL('crypt')}. Its corresponding provide object is
added to module @file{ext-crypt} in the @file{Makefile.py} of that
module, by saying @code{PROVIDE_SYMBOL('crypt')}.

@item
@findex REQUIRE_H
@code{@strong{REQUIRE_H()}}. Add a require object of type ``C/C++
@code{#include} directive''.

Parameters:

@itemize @bullet

@item
@code{filename}. String; required; A file name as if it were seen in a
C preprocessor @code{#include} directive, with the quotes stripped.

@end itemize

@item
@cindex require object, symbolic
@cindex symbolic require object
@findex REQUIRE_SYMBOL
@code{@strong{REQUIRE_SYMBOL()}}. Add a require object of type
``symbol'' that can be resolved by a provide object added using
@code{PROVIDE_SYMBOL()}. See there for further explanation.

Parameters:

@itemize @bullet

@item
@code{symbol}. String; required; the symbol's name.

@end itemize

@item
@findex FEATURE_MACRO
@findex AC_DEFINE
@cindex @code{AC_DEFINE}
@cindex module availability
@cindex availability, of modules
@code{@strong{FEATURE_MACRO()}}. Define a macro (using the
@code{AC_DEFINE} Autoconf macro) in @file{config.h} when this module
is available during the build of a package. If the macro is defined
(the module is available), then its value is 1. See @ref{Optionally
Building and Using Modules} for how one can enable and disable either
the build of a module when building the containing package, or build
another package with or without an installed module.

Parameters:

@itemize @bullet

@item
@code{macroname}. String; required; the macro.

@item
@code{description}. String; required; the description of the
macro. This is put into the generated @code{config.h}, right before
the macro definition. @code{description} is the third parameter to the
Autoconf @code{AC_DEFINE} macro; see there for more detailed
information.

@end itemize

@item
@findex EXTERNAL_LIBRARY
@code{@strong{EXTERNAL_LIBRARY()}}. Make the module a wrapper around a
library which is not maintained by Confix. See @ref{Using Third Party
Libraries} for an overall explanation and an example.

Parameters:

@itemize @bullet

@item
@code{name}. The name which identifies the library in the
corresponding Autoconf feature test macro as well as in the
corresponding argument to the @command{configure} program. The
Autoconf feature test macro's name is
@code{HAVE_CONFIX_EXT_<name>}. The @command{configure} argument to
switch the library on or off and to specify the path is
@code{--with-ext-<name>}. The value can either be 'yes', 'no', or the
prefix (the root) directory where the library and its header files are
installed.

@item
@code{enabled}. String; values are either 'yes' or 'no'; defaults to
'yes'. Determines the default value of the @command{configure}
argument @code{--with-ext-<name>}.

@item
@code{lib_bases}. String list; optional; defaults to the empty list. A
list of library base names, each of which will appear on the link line
as @code{-l<each>}. If there is no library but rather a set of header
files which you intend to direct the include path to, then you may
safely leave the list empty.

@item
@code{defroot}. String; optional; defaults to @file{/usr/local}. The
prefix taken if the user does not explicitly specify one using
@code{--with-ext-<name>}.

@item
@code{incdir}. String; optional; defaults to @code{include}. The
relative path inside the library's prefix directory where the header
files are. For example, if the library's prefix were
@code{/usr/local}, then the header files would be taken from
@file{/usr/local/include}.

@emph{Note} that the empty string means that there should no include
path be set for this module. If you want the include path for that
module to be the same as the prefix, specify @code{incdir='.'}.

@item
@code{libdir}. String; optional; defaults to @file{lib}. Same
semantics as @code{incdir}.

@item
@code{provide}. String list; optional; defaults to the empty
list. Shorthand for calling @code{PROVIDE_H(elem, 'public')} for each
list element.

@item
@cindex provide object, symbolic
@cindex symbolic provide object
@code{provide_symbols}. String list; optional; defaults to the empty
list. Shorthand for calling @code{PROVIDE_SYMBOL(elem, 'public')} for
each list element. @emph{Note} that, while the default values of
@code{provide_symbols} and @code{provide} are the empty list, it does
not make much sense to leave them both empty --- you want the library
to be linked in, in the end, and that's what provides are for.

@item
@code{require}. String list; optional; defaults to the empty
list. Shorthand for calling @code{REQUIRE_H()} for each list
element. Specifying require objects for an external library enables
you to build a dependency graph of external libraries. @emph{Note}
however that you should take care not to introduce dependencies back
into the set of Confix managed modules, unless you know what you are
doing.

@item
@cindex require object, symbolic
@cindex symbolic require object
@code{require_symbols}. String list; optional; defaults to the empty
list. Shorthand for calling @code{REQUIRE_SYMBOL(elem)} for each list
element. The same notes hold as for the @code{require} parameter.

@end itemize

@item
@findex IGNORE_FILE
@code{@strong{IGNORE_FILE()}}. Specify a file that must be
ignored. Sometimes you want to keep source files around in a directory
without compiling them, and this is when you use this function. It is
only applicable when Confix guesses the build instruction in that
directory. When you specify build instruction explicitly for that
module, this statement has no effect.

Parameters:

@itemize @bullet

@item
@code{filename}. String; required; The file name.

@end itemize

@item
@cindex name, of a library
@cindex library name
@vindex LIBNAME, module property
@findex LIBNAME, module interface
@findex MODULE_PROPERTIES
@code{@strong{MODULE_PROPERTIES()}}. Set properties of a module. Can
be called multiple times in the module's @file{Makefile.py}. If a
property had already been set, each successive call overrides that
property if the same property is given again.

Parameters:

@itemize @bullet

@item
@code{properties}. Dictionary; required. Keys must be strings, the
@emph{properties}. The values depend on the semantics of the
particular property. Currently, valid properties are,

@itemize @bullet

@item
@vindex LIBNAME, module property
@code{'LIBNAME'}. Value is a non-empty string, the base name of the
library built by the module. For example, if you give '@code{foo}',
and static libraries (archives) are built, the name of the archive
file will be @code{libfoo.a} (at least on most operating systems).

@end itemize

@end itemize

@item
@cindex name, of a library
@cindex library name
@vindex LIBNAME, module property
@findex LIBNAME, module interface
@code{@strong{LIBNAME()}}. Set the @code{'LIBNAME'} module
property. @code{LIBNAME('foo')} is only a shorthand for
@code{MODULE_PROPERTIES(@{'LIBNAME': 'foo'@})}.

Parameters:

@itemize @bullet

@item
@code{name}. String; required. A non-empty string, the library's base
name.

@end itemize


@item
@findex FILE_PROPERTIES, module interface
@cindex source file properties
@cindex properties, of source files
@code{@strong{FILE_PROPERTIES()}}. Set properties of a source file.

Parameters:

@itemize @bullet

@item
@code{filename}. String; required. A shell-like match expression which
identifies the files to which the given properties should apply. The
match is evaluated by the Python @code{fnmatch.fnmatchcase()}
function.

@item
@code{properties}. Dictionary; required. See the description of
@code{FILE_PROPERTIES()} in @ref{The Buildable Interface}, for valid
properties and their meanings. In fact, calling this function in the
module's @file{Makefile.py} has just the same effect as calling the
equivalent function in the source file itself, except that the latter
has precedence.

@end itemize


@item
@findex INSTALLDIR_H
@cindex header files, installing
@cindex installation directory, and header files
@code{@strong{INSTALLDIR_H()}}. Specify the directory where this
module's header files will be installed. Normally, when you do not set
this property, the header files will be installed into a directory
that is derived from the C++ namespaces (if any) contained in the
header files. @xref{Namespaces, Installation --- A Short
Example}. This property disables namespace guessing --- all header
files maintained by this module will be installed into the given
directory.

Parameters:

@itemize @bullet

@item
@code{dir}. String; required. The header files installation directory,
a path name relative to @code{$(includedir)}. An empty string is ok,
in this case the header files will be installed directly into
@code{$(includedir)}.

@end itemize

@item
@findex MAKEFILE_AM
@code{@strong{MAKEFILE_AM()}}. Add a line to the resulting
@file{Makefile.am}. This is used to pass custom build instructions
through to the @file{Makefile.am} which is generated by Confix.

Use this function with care. If you want to, for example, add a file
to the package which is made by @command{make dist}, you must not add
a line like 

@example
EXTRA_DIST = somefile
@end example

Confix maintains such a list internally; it contains (at least) the
module's @file{Makefile.py} file. By adding the above line literally,
you would get in conflict with Confix. To get around this, you should
add your @code{EXTRA_DIST} files to Confix's internal list, by using
the @code{EXTRA_DIST()} function described below.

Parameters:

@itemize @bullet

@item
@code{line}. String; required. A ``line'', though the string may
contain multiple lines. It will appear in the resulting
@file{Makefile.am} file with a newline appended.

@end itemize

@item
@findex EXTRA_DIST
@vindex EXTRA_DIST
@code{@strong{EXTRA_DIST()}}. Add a filename to the @code{EXTRA_DIST}
variable of the module's @file{Makefile.am}. You do this if you have
files in the module's directory that are not automatically packaged by
@command{make dist}. See the Automake documentation for more.

Parameters:

@itemize @bullet

@item
@code{filename}. String.

@end itemize

@c @item
@c @findex MANAGE_H
@c @code{@strong{MANAGE_H()}}. Add a buildable of type ``C/C++ header
@c file'' to the list of managed buildables.
@c 
@c Parameters:
@c 
@c @itemize @bullet
@c 
@c @item
@c @code{filename}. String; required. The name of the header file.
@c 
@c @item
@c @code{require_includes}. String list; optional; defaults to empty
@c list. List of files as if they were seen in a C preprocessor
@c @code{#include} directive (with the quotes stripped). These will be
@c added to the module as requires.
@c 
@c @item
@c @code{guess_require_includes}. String; values are either 'yes' or
@c 'no'; optional; defaults to 'yes'. A flag that indicates whether the
@c file should be parsed for further requires.
@c 
@c @item
@c @code{provide_mode}. String; values are either 'public', 'package', or
@c 'guess'; optional; defaults to 'guess'. Determines the provide's
@c visibility: 'public' means it will be visible (after installation) to
@c modules of other packages, 'private' means that it is only visible
@c during build to modules of the same package, and 'guess' means that
@c visibility will be guessed based on its filename.
@c 
@c @end itemize
@c 
@c @item
@c @findex MANAGE_CXX
@c @code{@strong{MANAGE_CXX()}}. Add a buildable of type ``C++ file'' to
@c the list of managed buildables.
@c 
@c Parameters:
@c 
@c @itemize @bullet
@c 
@c @item
@c @code{filename}. String; required. The name of the C++ file.
@c 
@c @item
@c @code{main}. String; values are either 'yes', 'no', or 'guess';
@c optional; defaults to 'guess'. A value of 'yes' indicates that this
@c file contains the @code{main()} function, and that an executable
@c should be built.
@c 
@c @c jjj FIXME: elaborate on this further, once guessing *and* 
@c @c explicitness is supported
@c 
@c @item
@c @code{guess_require_includes}. See @code{MANAGE_H()}.
@c 
@c @end itemize
@c 
@c @item
@c @findex MANAGE_C
@c @code{@strong{MANAGE_C()}}. Add a buildable of type ``C file'' to the
@c list of managed buildables.
@c 
@c Parameters: as @code{MANAGE_CXX()}.
@c 
@c @item
@c @findex MANAGE_ARCHIVE
@c @code{@strong{MANAGE_ARCHIVE()}}. Add a buildable of type ``archive''
@c (a library consisting of C/C++ files) to the list of managed
@c buildables.
@c 
@c Parameters:
@c 
@c @itemize @bullet
@c 
@c @item
@c @code{name}. String; optional; defaults to the empty string. The base
@c name of the archive, which is likely to end up being called
@c @code{lib<name>.a}. If the name parameter is left empty, then its
@c value is a mangled version of the module's name. The preferred way is
@c to leave it empty, unless you have a good reason@footnote{For example,
@c if the library is subject to be used by code that is not managed by
@c Confix}. If you don't care, you will never be bothered by library
@c names because your link lines will be generated by Confix.
@c 
@c @item
@c @code{members}. String list; required. A list of source file names
@c that participate in the library. Each of these files must have been
@c added to the module's list of buildables. At least one filename must
@c be given. @emph{Note} that header files must be added to the archive
@c as well.
@c 
@c @end itemize
@c 
@c @item
@c @findex MANAGE_EXECUTABLE
@c @code{@strong{MANAGE_EXECUTABLE()}}. Add a buildable of type
@c ``executable'' to the list of managed buildables.
@c 
@c Parameters:
@c 
@c @itemize @bullet
@c 
@c @item
@c @code{main}. String; optional. The name of the participating source
@c file that contains the @code{main()} function.
@c 
@c @item
@c @code{name}. String; optional. The name of the resulting executable.
@c 
@c @item
@c @code{members}. String list; required. The list of source files which
@c result in compiled object code, and which should appear on the link
@c line. At least one source file should be specified; although it might
@c seem obvious that this list contains the file which defines the
@c @code{main()} function, this is by no means required.
@c 
@c @item
@c @code{what}. String; values are either 'bin', 'check', or 'noinst';
@c optional; defaults to 'bin'. According to Automake's rules@footnote{In
@c the Automake manual they call these rules ``Uniform Naming Scheme''.},
@c a value of 'bin' makes the executable a regular program which will be
@c installed to the regular place; a value of 'check' make it a test
@c program which added to the automatic test suite (see also
@c @ref{Performing Automatic Tests}) and does not get installed; and a
@c value of 'noinst' makes it a normal program which is not installed.
@c 
@c @end itemize
@c 
@c One and only one of @code{main} and @code{name} must be specified. If
@c @email{main} is specified, the executable's name is a mangled
@c incarnation of the concatenation of the module name and the main
@c file. If @code{name} is specified, this is the executable's name.
@c 
@end itemize

@node The Buildable Interface, The Toplevel Makefile.py Interface, The Module Makefile.py Interface, Interfaces for Coder and Maintainer
@comment  node-name,  next,  previous,  up
@appendixsec The Buildable Interface

@cindex interface functions, buildable
@cindex buildable, interface functions
We have heard about Confix's concept of @emph{buildables}. A buildable
can be a single source file which is cooked by a compiler to produce an
object file. It can also be a collection of buildable objects which is
itself a buildable, such as a library or an executable. While it does
not make sense to specify build instructions in an executable though
(which has not even been built yet), it does make sense to specify them
in source files. Consider the example in @ref{Explicitly Adding Checks},
where we wrote an Autoconf check for the C++ class @code{stringstream}
in the same source file where we used its result, the macro
@code{HAVE_SSTREAM}.

Before we present a list of all interface functions you can use from a
buildable's source, let us say a few words about how the calls to the
functions are embedded in the various buildable types (well, the only
buildable types that implement embedded Confix code are C and C++, so
talking about a great variety of them is somewhat academic).

All Confix code in a buildable has to be written inside comment blocks
which are specially shaped. For C++, the comments have to be of the
form,

@example
// CONFIX:FILE_PROPERTIES(@{'MAIN': 0@})
@end example

These blocks can be multiline,

@example
@group
// CONFIX:FILE_PROPERTIES(
// CONFIX:     @{'MAIN': 0@}
// CONFIX:)
@end group
@end example

They need not necessarily contain Confix interface functions. Rather,
you can write arbitrary Python code there. For example (rather useless
though),

@example
// CONFIX:import dircache
// CONFIX:for f in dircache.listdir('.'):
// CONFIX:    print f
@end example

When Confix parses the source file, it collects all lines that have
that pattern, concatenates them, and executes them in the same
context. This means that the Python code can be spread all over the
source file. You can allocate variables in one place, and refer to
them in another place (provided that ``another place'' comes after
``one place'' in the file).

Please note that the Python parser is very particular about indentation
--- indentation in Python is syntactically equivalent to putting braces
in C. It is important to understand that everything @emph{immediately}
after the initial @code{// CONFIX:} is passed to the Python interpreter
literally, and the interpreter will bail out if you get it wrong.

The @file{wx-utils} package accompanying the Confix distribution
contains a few invocation of the buildable interface, see for example
the file @file{error/error.cc}.

So, concluding the story, here's the list of interface functions you can
use inside source files.

@itemize @bullet

@item
@findex CONFIGURE_IN, buildable interface
@findex CONFIGURE_IN
@code{@strong{CONFIGURE_IN()}}. @CONFIGUREINcommon{The buildable
interface}

@itemize @bullet

@item
@code{lines}. @CONFIGUREINlines

@item
@code{order}.

@CONFIGUREINorder

@end itemize

@item
@findex ACINCLUDE_M4, buildable interface
@findex ACINCLUDE_M4
@code{@strong{ACINCLUDE_M4()}}. @ACINCLUDEcommon{The buildable
interface}

@itemize @bullet

@item
@code{lines}. @ACINCLUDElines

@item
@code{id}. @ACINCLUDEid

@end itemize

@item
@findex FILE_PROPERTIES, buildable interface
@cindex file properties, buildable interface
@cindex properties, of source files
@cindex source file properties
@code{@strong{FILE_PROPERTIES()}}. Set properties of the source
file. When this function is called multiple times in a source file, if a
property had already been set, each successive call overrides that
property if the same property is given again. Note that not every
property is valid for every source file type.

Parameters:

@itemize @bullet

@item
@code{properties}. Dictionary; required. Keys must be strings, the
@emph{properties}. The values depend on the semantics of the
particular property. Currently, valid properties are,

@itemize @bullet

@item
@vindex MAIN, source file property
@code{'MAIN'}. Value is boolean, and can be one of @code{'yes', 'no',
'y', 'n', 'true', 'false', 't', 'f', '1', '0', 1, 0}. This property
keeps Confix from searching the source file for occurences of the word
@code{main}, and from guessing from it that the file contains the
definition of the @code{main()} function. See @ref{Library or
Executables?} for an explanation of the effects of this property on
the build process.

Valid only for C and C++ source files (not valid for C/C++ header
files).

@item
@vindex EXENAME, source file property
@code{'EXENAME'}. Value is a string which must not be empty. You use
this file property to control the name of an executable. Without this
property the executable name is automatically generated by Confix; see
also @ref{Library or Executables?}.

Valid only for C and C++ source files (not valid for C/C++ header
files), and only if that file has the @code{'MAIN'} property (either
explicit or implicit).

@item
@vindex PROVIDE_MODE, source file property
@code{'PROVIDE_MODE'}. Value is a string, namely one of
@code{'public'}, @code{'private'}, @code{'guess'} (the default). If
the file is recognized by Confix as a C header file, the behavior is
as follows. @code{'private'} means that the file will not be
installed, and is only visible to member files of the same
package. @code{'public'} means that the file will be
installed. @code{'guess'} resorts to the default behavior --- make the
file private if its name starts with an underscore, else public.

@end itemize

@end itemize

Example:

@example
FILE_PROPERTIES(@{'MAIN': 'false'@})
@end example

@item
@findex MAIN
@code{@strong{MAIN()}}. Receives a parameter, @code{main}, which is boolean the
same way as the @code{'MAIN'} property of @code{FILE_PROPERTIES()}. In
fact, for example, calling

@example
MAIN('false')
@end example

is just a shorthand for calling

@example
FILE_PROPERTIES(@{'MAIN': 'false'@})
@end example

@item
@findex EXENAME
@code{@strong{EXENAME()}}. Receives a string parameter,
@code{name}. Calling

@example
EXENAME('foobar')
@end example

is exactly the same as calling

@example
FILE_PROPERTIES(@{'EXENAME': 'foobar'@})
@end example

@item
@findex REQUIRE_H
@cindex resolving, dependencies
@code{@strong{REQUIRE_H()}}. Add a require object of type ``C/C++
@code{#include} directive''. To the resolving process, writing

@example
@code{REQUIRE_H('a_file.h')}
@end example

has the same effect as writing @code{#include <a_file.h>} into the
source file directly, it's just that the preprocessor is passed by.

Parameters:

@itemize @bullet

@item
@code{filename}. String; required; A file name as if it were seen in a
C preprocessor @code{#include} directive, with the quotes stripped.

@end itemize


@item
@cindex require object, symbolic
@cindex symbolic require object
@findex REQUIRE_SYMBOL
@code{@strong{REQUIRE_SYMBOL()}}. Add a require object of type
``symbol''. Conceptually, this is nothing different from
@code{REQUIRE_H()} in that it influences module dependency
calculation. It's just that it's a cleaner way of hand-crafting the
dependency graph. It is likely to be used in conjunction with provide
objects of type ``symbol'' that were introduced by a call to
@code{PROVIDE_SYMBOL()} or @code{EXTERNAL_LIBRARY()}.

Parameters:

@itemize @bullet

@item
@code{symbol}. String; required; Roughly, a C like symbol, but can
actually be anything you want.

@end itemize

@end itemize

@node The Toplevel Makefile.py Interface,  , The Buildable Interface, Interfaces for Coder and Maintainer
@comment  node-name,  next,  previous,  up
@appendixsec The Toplevel (Package) @file{Makefile.py} Interface

@cindex package, interface functions
@cindex interface functions, package
@cindex toplevel, interface functions
@cindex interface functions, toplevel
@cindex package version
Optionally, you can place a @file{Makefile.py} in the package's root
directory as well. This file has a syntax similar to the module's
interface file (see @ref{The Module Makefile.py Interface}), in that it
is all Python code. Unlike the module's @file{Makefile.py} you use this
file to manipulate package properties, such as the package name
(remember, that one is derived from the package root directory's base
name if you don't explicitly specify one), or the package's version
('0.0.0' by default, which is not overly informative).

@itemize @bullet

@item
@findex CONFIGURE_IN, package interface
@findex CONFIGURE_IN
@code{@strong{CONFIGURE_IN()}}. @CONFIGUREINcommon{The package
interface}

@itemize @bullet

@item
@code{lines}. @CONFIGUREINlines

@item
@code{order}.

@CONFIGUREINorder

@end itemize

@item
@findex ACINCLUDE_M4, package interface
@findex ACINCLUDE_M4
@code{@strong{ACINCLUDE_M4()}}. @ACINCLUDEcommon{The package interface}

@itemize @bullet

@item
@code{lines}. @ACINCLUDElines

@item
@code{id}. @ACINCLUDEid

@end itemize

@item
@cindex package name
@findex NAME
@code{@strong{NAME()}}. Set the package name.

Parameters:

@itemize @bullet

@item
@code{name}. String; the package name.

@end itemize


@item
@cindex package version
@findex VERSION
@code{@strong{VERSION()}}. Set the package version.

Parameters:

@itemize @bullet

@item
@code{version}. String; the package version. Should be something like
'1.2.3'.

@end itemize

@item
@findex EXTRA_DIST
@vindex EXTRA_DIST
@code{@strong{EXTRA_DIST()}}. Add a filename to the @code{EXTRA_DIST}
variable of the package's @file{Makefile.am}. You do this if you have
files in the package's toplevel directory that are not automatically
packaged by @command{make dist}. See the Automake documentation for
more.

Parameters:

@itemize @bullet

@item
@code{filename}. String.

@end itemize

@end itemize

@node The Configuration File, Frequently Asked Questions, Interfaces for Coder and Maintainer, Top
@comment  node-name,  next,  previous,  up
@appendix The Configuration File

The configuration file (by default @file{~/.confix}, though switchable
through the @option{--configfile=} option) is a snippet of Python code
which is executed by Confix to determine parameters.

Confix supports the notion of so-called @emph{profiles}. A profile is
a set of parameters you choose to be valid for one Confix run. We saw
an ad-hoc introduction of it in @ref{The Configuration File (Short
Introduction)}, where we only used one profile which contained the
@var{PREFIX} and @var{BUILDROOT} parameters. This saved us from having
to specify the options @option{--prefix} and @option{--builddir} every
time we called Confix.

There is a bit more to it:

@itemize @bullet

@item
The file can arbitrary Python code. You can even format your harddrive
if you want.

@item
The @var{PROFILES} dictionary can contain an arbitrary number of
profiles.

@end itemize

Confix's entry point into the configuration is the @var{PROFILES}
dictionary. This dictionary contains entries of the form,

@example
profile-name: profile
@end example

where @var{profile-name} is a string, and @var{profile} is a reference
to a dictionary which contains the parameter set for that profile. You
should define a profile whose name is @code{'default'} in case you
intend to call Confix without the @option{--profile} option. In this
case the @code{'default'} profile is selected; otherwise, if there is
no @code{'default'} profile, Confix flags an error.

A profile dictionary can contain the following entries. Whenever there
is a corresponding commandline option, the profile entry is overridden
by that option's value. Tilde and environment variable expansion is
performed on every value which is a path name.

@itemize @bullet

@item
@code{'PREFIX'}: a string containing the path name of the directory
where installation takes place. Same as the @option{--prefix} option.

@item
@code{'BUILDROOT'}: a string containing the path name of the directory
where we use to compile our packages. Same as the @option{--buildroot}
option.

@item
@cindex Libtool
@cindex shared libraries, and Libtool
@cindex libraries, shared, Libtool
@code{'USE_LIBTOOL}: a boolean flag, can be 0 or 1 (or left
unspecified, of course). If you specify this flag, output will be
generated that makes use of Libtool. This means that building
libraries is done by Libtool, and, depending on the support of Libtool
for the target architecture, either shared or static libraries, or
both, will be built. By default this is switched off, and output is
generated that builds plain archives, without Libtool. This parameter
is overridden by the @option{--use-libtool} option.

@item
@code{'CONFIGURE'}: a dictionary containing the commandline arguments
and environment variables which are passed to @command{configure}
invocations.

@itemize @bullet

@item
@code{'ENV'}: a dictionary with string-to-string mappings which define
the environment. Confix executes @command{configure} with an
environment which is as clean as possible, and which is fills with the
contents of this environment dictionary. A common application of a
custom environment is passing the @var{CC}, @var{CFLAGS}, @var{CXX}
and @var{CXXFLAGS} to set a custom compiler and associated flags, for
example.

@code{'ARGS'}: a list of strings which are passed to
@command{configure} as command line parameters. Confix arranges to add
the @option{--prefix} to the command line, from its own @var{prefix}
setting.

@end itemize

@item
@code{'MAKE'}: a dictionary containing the commandline arguments and
environment variables which are passed to @command{configure}
invocations. Its contents and their handling are exactly the same as
with the @code{'CONFIGURE'} profile entry.

@end itemize

What follows is a sample @file{.confix} file containing two different
profiles which are hooked into the global @var{PROFILES}
dictionary. The purpose of the profiles is to define two sets of
parameters for compilation of two different branches of the same
source code base. Note that this is only an example; you could use
custom profiles to compile the same source code into two different
location with two different compilers, for example, if you want to try
out if your Autoconf checks work ok. Whatever comes to mind is valid.

@example
@group
main_conf = @{

    'PREFIX': '~/wxpackages/main',
    'BUILDROOT': '~/compile/main',
    
    'CONFIGURE': @{
    
       'ENV': @{
          'CC': '/usr/local/gcc-2.95.2.1/bin/gcc',
          'CXX': '/usr/local/gcc-2.95.2.1/bin/g++',
          'CFLAGS': "-g -O0 -Wall -DWXDEBUG",
          'CXXFLAGS': "-g -O0 -Wall -DWXDEBUG",
          @},

       'ARGS':
         ['--with-ext-XERCESC=/usr/local/xercesc-1.7.0-gcc-2.95.2.1',
          '--with-ext-MICO=/usr/local/mico-ccm-020124.gcc-2.95.2.1']

       @},

    'MAKE': @{
       
       @}
    @}
@end group
@end example

@example
@group
read_conf = @{

    'PREFIX': '~/wxpackages/read',
    'BUILDROOT': '~/compile/read',
    
    'CONFIGURE': @{

       'ENV': @{
          'CC': '/usr/local/gcc-2.95.2.1/bin/gcc',
          'CXX': '/usr/local/gcc-2.95.2.1/bin/g++',
          'CFLAGS': "-g -O0 -Wall -DWXDEBUG",
          'CXXFLAGS': "-g -O0 -Wall -DWXDEBUG",
          @},

       @},

    'MAKE': @{
       
       @}
    @}
@end group
@end example

@example
@group
PROFILES = @{
    'default': main_conf,
    'main': main_conf,
    'read': read_conf
    @}
@end group
@end example

@node Frequently Asked Questions, The Sample Utilities Package, The Configuration File, Top
@comment  node-name,  next,  previous,  up
@appendix Frequently Asked Questions

@menu
* When should I bootstrap my package?::  
* What should I do when the Autotools bail out?::  
@end menu

@node When should I bootstrap my package?, What should I do when the Autotools bail out?, Frequently Asked Questions, Frequently Asked Questions
@comment  node-name,  next,  previous,  up
@appendixsec When should I bootstrap my package?

You need to bootstrap your package if one or more of the following is
true.

@itemize @bullet

@item
You never bootstrapped your package before.

@item
You modified any of the @file{Makefile.py} files in the package

@item
You introduced a new dependency in a module of the package. Commonly
this is the case when you added a @code{#include} line which includes
a header file from another module. You only need to re-bootstrap if
this is a new dependency --- that is, if no file of the module
included a file of the other module before.

@item
You added a source file.

@item
You removed a source file.

@item
You are unclear if you should re-bootstrap your package.

@end itemize

@node What should I do when the Autotools bail out?
@comment  node-name,  next,  previous,  up
@appendixsec What should I do when the Autotools bail out?

It's hard to say what to do when you see an error that comes from one
of the Autotools. I suggest you take the error message, launch your
pattern matching engine now, and skim through the following list.

@itemize @bullet

@item
@findex AM_CONFIG_HEADER
@findex AC_CONFIG_HEADER
@vindex WANT_AUTOMAKE
@code{configure.in: 20: `automake requires `AM_CONFIG_HEADER', not
`AC_CONFIG_HEADER'}

You are using an old automake version, probably 1.5 or even
earlier. Upgrade automake to at least 1.7.

Some Linux distribution come with two different versions
installed. These are named, for example, @code{automake-1.5} and
@code{automake-1.8} A wrapper script named @code{automake} examines
the package that is being bootstrapped and dispatches the call to
either of the real programs, based on what it sees in the
packages. Ugly, ugly, but it appears to work most of the time. When it
does not work --- which is why you see the error --- you have to
explicitly demand a particular version. You do this by setting an
environment variable,

@example
@group
$ export WANT_AUTOMAKE=1.8
@end group
@end example

@end itemize

@node The Sample Utilities Package, Concept Index, Frequently Asked Questions, Top
@comment  node-name,  next,  previous,  up
@appendix The Sample Utilities Package

The @code{wx-utils} package contains a few helpful things that my
co-workers and me use in daily work. Although it is maintained
independently, it serves as a pool of examples that we can refer to
from this manual. Here's a brief explanation of what's in there,
module by module.

@itemize @bullet

@item
@file{code}. A loose collection of small coding utilities, such as

@itemize @bullet

@item
A smart-pointer template class.

@item
A debug macro, with configurable debug levels.

@item
Link time assertion macros. See @file{wx-utils/code/linkassert.h} for
more.

@item
Macros for alignment calculation, @code{extern "C"} declarations, etc.

@end itemize

@item
@file{error}. An error class, ready to be thrown as exception. Errors
can be nested: you catch an exception that is of type @code{Error} or
some derived type, wrap it into your own @code{Error} type or even an
object of the base class, and throw that object to your caller. This
way you get a trace of errors. There are also macros available which
make throwing and wrapping more comfortable.

@item
@file{threads}. Several threading utilities, such as mutex and
condition variable classes. They are only thin wrappers around
threading primitives of the operating system, and are supposed to use
external library definitions in other modules. The
@file{wx-utils/ext-pthread} module is an example.

@item
@file{txn}. Classes that help coordinate database transactions in a
clean way. The design is stolen from the Object Transaction Service
(OTS) of the Object Management Group (OMG). We do not coordinate
distributed transactions however, but only transactions in the same
address space as the objects that use them (which is hard enough
though).

@item
@file{types}. A framework that makes it possible to have polymorphical
value objects which have a type associated with them. The framework
looks like (a small subset of) CORBA's Dynamic Any suite, in that the
struct and enumeration types can be used just like CORBA's typecodes
for @code{DynStruct} and @code{DynEnum}.

@end itemize

@node Concept Index, Function Index, The Sample Utilities Package, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@node Function Index, Variable Index, Concept Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@node Variable Index,  , Function Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Variable Index

@printindex vr

@contents
@bye
