Confix 1.2.0 Released
---------------------

Confix does what is otherwise the job of the package maintainer: write
input files for Automake and Autoconf. By examining the package
source, it determines how to shape configure.in and the different
Makefile.am files in the package in order to perform a clean build.

Homepage, Download
------------------

Confix is hosted by Sourceforge. The home page is
http://confix.sf.net, where you can find a link to the project summary
and download page. Note that it may take some time until the packages
have reached the mirror sites, so you may have to wait a bit, or try
out several mirrors.

Incompatibilities in 1.2
------------------------

As always, the module description file format has changed, so it is
necessary that the user remove the files in ${prefix}/repo and
re-bootstrap and re-install all packages.

New features in 1.2
-------------------

- Arbitrary multiline Confix/Python code in source files

  You can put arbitrary Python code, supposedly peppered with Confix
  statements, into comments in the C/C++ source files. See "B.3 The
  Buildable Interface".

- Dependency resolving speedup (by roughly 70% (!)).

  This was partly a bug fix ("[ 668591 ] repo files contain requires
  that are resolved internally") which happened to have an enormous
  positive performance impact. I also applied a few caches here and
  there, which makes this a feature formally.

- Pass-through of Makefile.am pieces.

  You can now add code to a module's Makefile.py which is passed
  through to the generated Makefile.am. While this should not be
  overused, it can be helpful in certain situations where bloody
  Confix lacks functionality. See "B.2 The Module Makefile.py
  Interface".

- New require and provide object type: symbols.

  In previous releases dependency calculation was only done by
  including C header files and providing them. Now we can do the same
  symbolically. You need this, for example, when you want to link the
  crypt library: that library defines the symbol 'crypt', but it
  certainly doesn't provide the header file, <unistd.h>, which
  declares that symbol.

  The module and buildable interfaces were extended to make such
  requires and/or provides easily specified. See "B.2 The Module
  Makefile.py Interface", and "B.3 The Buildable Interface".

- Optional modules

  Every module is now optional. You can switch off the usage of an
  installed module with the corresponding --with-<modulename>
  configure option. Likewise, during package build you can exclude
  modules selectively by using the --disable-<modulename> option.

  The handling of external modules (those which use the
  EXTERNAL_LIBRARY() function in their Makefile.py) has been modified
  to fit into this scheme. This means that the configure --with/enable
  options of these modules have changed.

  Feature macros are defined so that user code can determine if a
  module has been switched off. One feature macro is defined
  automatically by Confix, and the maintainer can specify additional
  feature macros.

  Not yet documented, but try `configure --help` for a quick overview
  of which --enable/--with options are available.

- Multiple configuration files.

  It is possible to pass a list of configuration files on the
  commandline. This way one can have one basic configuration, and
  construct overlays and additions in separate files. See "A.2
  Parameters".
